<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat Movicel</title>
 
<style>
:root{
  --bg:#f2f5f7; --card:#fff; --line:#e6e9ef; --text:#1f2937; --muted:#6b7280;
  --brand:#1a73e8; --in:#ffffff; --out:#1a73e8; --out-text:#ffffff; --radius:14px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg:#181818; --card:#2a2a2a; --line:#404040; --text:#ffffff; --muted:#a0a0a0;
    --brand:#4285f4; --in:#3a3a3a; --out:#4285f4; --out-text:#ffffff;
  }
}

*{box-sizing:border-box}
body{width:100%; margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;background:var(--bg);color:var(--text);overflow:hidden}
#app{display:grid;grid-template-columns:100% 1fr;width:100%;height:100vh;max-height:100vh}

/* Splash Screen */
.splash-screen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 1;
  transition: opacity 0.8s ease;
}

.splash-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

.splash-logo {
  width: 120px;
  height: 120px;
  background: white;
  border-radius: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 48px;
  margin-bottom: 20px;
  animation: pulse 2s infinite;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.splash-title {
  color: white;
  font-size: 28px;
  font-weight: 700;
  margin-bottom: 10px;
  text-align: center;
}

.splash-subtitle {
  color: rgba(255,255,255,0.8);
  font-size: 16px;
  text-align: center;
  margin-bottom: 30px;
}

.splash-loader {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255,255,255,0.3);
  border-top: 3px solid white;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.splash-status {
  color: rgba(255,255,255,0.9);
  font-size: 14px;
  margin-top: 20px;
  text-align: center;
  min-height: 20px;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* PIN Security */
.pin-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.9);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 90000;
  backdrop-filter: blur(10px);
}

.pin-modal {
  background: var(--card);
  border-radius: 20px;
  padding: 30px;
  max-width: 350px;
  width: calc(100% - 40px);
  text-align: center;
  box-shadow: 0 20px 40px rgba(0,0,0,0.3);
}

.pin-title {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 10px;
  color: var(--text);
}

.pin-subtitle {
  color: var(--muted);
  margin-bottom: 30px;
  font-size: 14px;
}

.pin-input {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-bottom: 30px;
}

.pin-digit {
  width: 50px;
  height: 50px;
  border: 2px solid var(--line);
  border-radius: 12px;
  text-align: center;
  font-size: 24px;
  font-weight: 700;
  background: var(--card);
  color: var(--text);
  transition: all 0.2s ease;
}

.pin-digit:focus {
  border-color: var(--brand);
  outline: none;
  transform: scale(1.05);
}

.pin-digit.filled {
  background: var(--brand);
  color: white;
  border-color: var(--brand);
}

.pin-buttons {
  display: flex;
  gap: 12px;
  justify-content: center;
}

.pin-btn {
  padding: 12px 24px;
  border: none;
  border-radius: 10px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pin-btn.primary {
  background: var(--brand);
  color: white;
}

.pin-btn.secondary {
  background: var(--line);
  color: var(--text);
}

.pin-btn:hover {
  transform: translateY(-1px);
  opacity: 0.9;
}

.pin-error {
  color: #ef4444;
  font-size: 12px;
  margin-top: 10px;
  display: none;
}

.sidebar, .chat {
  display: none;
}
.sidebar.active, .chat.active {
  display: flex;
}

.sidebar{background:var(--card);border-right:1px solid var(--line);flex-direction:column}
.topbar{padding:12px 14px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:10px }
.me{display:flex;align-items:center;gap:10px;flex:1}

.me .avatar{
  width:36px;
  height:36px;
  border-radius:50%;
  object-fit:cover;
  background:linear-gradient(135deg, #667eea, #764ba2);
  border: 2px solid var(--line);
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 600;
  font-size: 12px;
  cursor: pointer;
}

.me .avatar.loaded {
  background: none;
}

.me .avatar:hover {
  transform: scale(1.05);
  border-color: var(--brand);
}

.me .info{display:flex;flex-direction:column}
.me .info .name{font-weight:600;font-size:14px}
.me .info .email{font-size:12px;color:var(--muted)}

.actions{display:flex;gap:8px}
.actions button{color:#fff;border:0;border-radius:0px;padding:0px 0px;cursor:pointer;transition:all 0.2s ease}
.actions button:hover{opacity:0.9;transform:translateY(-1px)}

/* Tabs Navigation */
.tabs-nav {
  display: flex;
  border-bottom: 1px solid var(--line);
  background: var(--card);
}

.tab-btn {
  flex: 1;
  padding: 12px 8px;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s ease;
}

.tab-btn.active {
  color: var(--brand);
  border-bottom-color: var(--brand);
}

.tab-btn:hover {
  background: var(--line);
}

.tab-content {
  display: none;
  flex-direction: column;
  flex: 1;
  overflow: hidden;
}

.tab-content.active {
  display: flex;
}

.search{padding:8px 12px;border-bottom:1px solid var(--line)}
.search input{width:100%;padding:10px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}

.user-list{list-style:none;margin:0;padding:0;overflow:auto;flex:1}
.user-item{display:grid;grid-template-columns:48px 1fr auto;align-items:center;gap:10px;padding:10px 12px;cursor:pointer;border-bottom:1px solid var(--line);transition:background-color 0.2s ease}
.user-item:hover{background:rgba(26,115,232,0.05)}

.avatar{
  width:44px;
  height:44px;
  border-radius:50%;
  object-fit:cover;
  background:linear-gradient(135deg, #667eea, #764ba2);
  border: 2px solid var(--line);
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 600;
  font-size: 14px;
  flex-shrink: 0;
  cursor: pointer;
}

.avatar.loaded {
  background: none;
}

.avatar:hover {
  transform: scale(1.05);
  border-color: var(--brand);
}

.u-main{display:flex;flex-direction:column;min-width:0}
.u-name{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:14px}
.u-preview{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-top:2px}
.u-right{text-align:right;display:flex;flex-direction:column;align-items:flex-end;gap:4px}
.u-time{font-size:11px;color:var(--muted)}
.dot{width:10px;height:10px;border-radius:50%;transition:all 0.2s ease}
.dot.online{background:#10b981;box-shadow:0 0 6px rgba(16,185,129,0.4)}
.dot.offline{background:#9ca3af}

/* Friend Action Button */
.friend-action {
  background: var(--brand);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.friend-action:hover {
  transform: translateY(-1px);
  opacity: 0.9;
}

.friend-action.remove {
  background: #ef4444;
}

.chat{flex-direction:column; width:100%; height:100vh;max-height:100vh}
.chat-header{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid var(--line);background:var(--card)}
.chat-header .avatar{width:40px;height:40px}
.title{display:flex;flex-direction:column;flex:1}
.title .name{font-weight:700;font-size:16px}
.title .status{font-size:12px;color:var(--muted);display:flex;align-items:center;gap:6px;margin-top:2px}

/* Chat Back Button */
.chat-back {
  background: none;
  border: none;
  color: var(--text);
  font-size: 18px;
  padding: 8px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.chat-back:hover {
  background: var(--line);
  transform: scale(1.05);
}

/* Chat Actions */
.chat-actions{display:flex;gap:8px;margin-left:auto}
.chat-btn{background:none;border:1px solid var(--line);color:var(--text);padding:6px 12px;border-radius:8px;cursor:pointer;font-size:12px;transition:all 0.2s ease}
.chat-btn:hover{background:var(--line)}
.chat-btn.block{border-color:#ef4444;color:#ef4444}
.chat-btn.block:hover{background:#ef4444;color:white}
.chat-btn.unblock{border-color:#10b981;color:#10b981}
.chat-btn.unblock:hover{background:#10b981;color:white}

.messages{flex:1;overflow:auto;padding:14px;background:var(--bg);display:flex;flex-direction:column;gap:10px}

/* Mensagens com Avatares e Status */
.row{display:flex;align-items:flex-start;gap:8px;margin-bottom:12px}
.row.in{justify-content:flex-start}
.row.out{justify-content:flex-end;flex-direction:row-reverse}

.message-avatar{
  width:32px;
  height:32px;
  border-radius:50%;
  object-fit:cover;
  background:linear-gradient(135deg, #667eea, #764ba2);
  border: 2px solid var(--line);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 600;
  font-size: 10px;
  flex-shrink: 0;
  margin-top: 4px;
  cursor: pointer;
}

.message-avatar.loaded {
  background: none;
}

.message-wrapper{
  display:flex;
  flex-direction:column;
  max-width:70%;
}

.bubble{
  padding:10px 12px;
  border-radius:16px;
  line-height:1.35;
  word-wrap:break-word;
  overflow-wrap:anywhere;
  box-shadow:0 1px 2px rgba(0,0,0,0.1);
}

.in .bubble{
  background:var(--in);
  border-bottom-left-radius:4px;
}

.out .bubble{
  background:var(--brand);
  color:var(--out-text);
  border-bottom-right-radius:4px;
}

.msg-img{border-radius:10px;max-width:100%;cursor:pointer;display:block}

/* Video Message Styles */
.msg-video{
  width: 100%;
  max-width: 320px;
  height: 180px;
  border-radius: 10px;
  border: none;
  background: #000;
  display: block;
}

.video-error {
  background: var(--line);
  color: var(--text);
  padding: 20px;
  border-radius: 10px;
  text-align: center;
  font-size: 12px;
  max-width: 320px;
}

.meta{font-size:11px;color:var(--muted);margin-top:4px;padding:0 4px;display:flex;align-items:center;gap:6px}

/* Message Status Icons */
.message-status {
  font-size: 10px;
  color: var(--muted);
  transition: all 0.2s ease;
}

.message-status.sent {
  color: #6b7280;
}

.message-status.delivered {
  color: #3b82f6;
}

.message-status.read {
  color: #10b981;
}

.composer{display:none;gap:8px;padding:10px;border-top:1px solid var(--line);background:var(--card)}
.composer button{background:var(--brand);color:#fff;border:0;border-radius:10px;padding:0 0px;cursor:pointer;height:40px;transition:all 0.2s ease}
.composer button:hover{opacity:0.9;transform:translateY(-1px)}

#textInput{flex:1;min-height:40px;max-height:120px;resize:none;padding:10px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}
#btnImage, #btnVideo{width:40px;display:grid;place-items:center}

.viewer{position:fixed;inset:0;background:rgba(0,0,0,.9);display:none;place-items:center;z-index:1000}
.viewer img{max-width:95vw;max-height:90vh;border-radius:12px}
.viewer-close{position:fixed;top:16px;right:16px;background:#111;color:#fff;border:0;border-radius:10px;padding:8px 12px;cursor:pointer}

/* Avatar Viewer */
.avatar-viewer{position:fixed;inset:0;background:rgba(0,0,0,.9);display:none;align-items:center;justify-content:center;z-index:1050;backdrop-filter:blur(4px)}
.avatar-viewer img{max-width:80vw;max-height:80vh;border-radius:20px;box-shadow:0 20px 40px rgba(0,0,0,0.5)}
.avatar-viewer-close{position:fixed;top:20px;right:20px;background:rgba(255,255,255,0.2);color:#fff;border:0;border-radius:50%;width:50px;height:50px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:20px;backdrop-filter:blur(10px)}
.avatar-viewer-name{position:fixed;bottom:30px;left:50%;transform:translateX(-50%);color:white;font-size:18px;font-weight:600;text-shadow:0 2px 10px rgba(0,0,0,0.5)}

/* Video URL Modal */
.video-modal{position:fixed;inset:0;background:rgba(15,23,42,0.8);display:none;align-items:center;justify-content:center;padding:20px;z-index:1150;backdrop-filter:blur(4px)}
.video-modal-card{background:var(--card);border-radius:16px;max-width:450px;width:100%;padding:20px;display:flex;flex-direction:column;gap:15px;box-shadow:0 20px 25px -5px rgba(0,0,0,0.1)}
.video-modal-card h3{margin:0;color:var(--text)}
.video-modal-card input{padding:12px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}
.video-modal-buttons{display:flex;gap:10px;justify-content:flex-end}
.video-modal-btn{padding:10px 20px;border:none;border-radius:8px;cursor:pointer;font-size:14px;font-weight:600;transition:all 0.2s ease}
.video-modal-btn.primary{background:var(--brand);color:white}
.video-modal-btn.secondary{background:var(--line);color:var(--text)}

.auth{position:fixed;inset:0;background:rgba(15,23,42,0.8);display:none;align-items:center;justify-content:center;padding:20px;z-index:1100;backdrop-filter:blur(4px)}
.auth-card{background:var(--card);border-radius:16px;max-width:380px;width:100%;padding:20px;display:flex;flex-direction:column;gap:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,0.1)}
.auth-card h2{margin:0;color:var(--text)}
.auth-card input{padding:10px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}
.row-line{display:flex;gap:8px}
.row-line>*{flex:1}

.profile{position:fixed;inset:0;background:rgba(15,23,42,0.8);display:none;align-items:center;justify-content:center;padding:20px;z-index:1200;backdrop-filter:blur(4px)}
.profile-card{background:var(--card);border-radius:16px;max-width:420px;width:100%;padding:20px;display:flex;flex-direction:column;gap:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,0.1)}
.profile-card h3{margin:0;color:var(--text)}
.profile-card label{color:var(--text);font-weight:500}
.profile-card input{padding:10px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}
.help{font-size:12px;color:var(--muted)}
.link{color:#DEBCCE;text-decoration:none}
.hidden{display:none}

/* PIN Settings */
.pin-settings {
  margin: 15px 0;
  padding: 15px;
  border: 1px solid var(--line);
  border-radius: 10px;
  background: var(--bg);
}

.pin-toggle {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.pin-toggle input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: var(--brand);
}

/* Blocked Users Modal */
.blocked-modal{position:fixed;inset:0;background:rgba(15,23,42,0.8);display:none;align-items:center;justify-content:center;padding:20px;z-index:1300;backdrop-filter:blur(4px)}
.blocked-card{background:var(--card);border-radius:16px;max-width:500px;width:100%;padding:20px;display:flex;flex-direction:column;gap:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,0.1);max-height:70vh;overflow:hidden}
.blocked-card h3{margin:0;color:var(--text)}
.blocked-list{flex:1;overflow:auto;margin:10px 0}
.blocked-item{display:flex;align-items:center;gap:12px;padding:12px;border:1px solid var(--line);border-radius:8px;margin-bottom:8px}
.blocked-item .avatar{width:40px;height:40px}
.blocked-item .info{flex:1}
.blocked-item .name{font-weight:600;margin-bottom:4px}
.blocked-item .email{font-size:12px;color:var(--muted)}
.unblock-btn{background:#10b981;color:white;border:0;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:12px}
.unblock-btn:hover{background:#059669}

.loading-placeholder {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

.back-button {
  display: inline-flex;
  background-color: transparent;
  align-items: center;
  gap: 8px;
  padding: 10px 6px;
  color: var(--text);
  font-size: 14px;
  font-weight: 600;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.back-button:hover {
  transform: scale(1.05);
  background: var(--line);
}

.toast-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-width: 400px;
}

.toast {
  padding: 12px 16px;
  border-radius: 8px;
  color: white;
  font-weight: 500;
  font-size: 14px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  transform: translateX(100%);
  animation: slideIn 0.3s ease forwards;
}

.toast.success { background: #10b981; }
.toast.error { background: #ef4444; }
.toast.info { background: #3b82f6; }

@keyframes slideIn { to { transform: translateX(0); } }
@keyframes slideOut { to { transform: translateX(100%); } }

/* Responsivo */
@media (max-width: 768px) {
  .message-wrapper { max-width: 85%; }
  .row { gap: 6px; }
  .message-avatar { width: 28px; height: 28px; font-size: 9px; }
  .chat-actions { gap: 4px; }
  .chat-btn { padding: 4px 8px; font-size: 11px; }
  .pin-input { gap: 10px; }
  .pin-digit { width: 45px; height: 45px; font-size: 20px; }
  .msg-video { max-width: 280px; height: 160px; }
}

.icon {
  background-color: #fff;   /* fundo branco */
  display: inline-flex;     /* centraliza o SVG */
  align-items: center;
  justify-content: center;
  border-radius: 4px;       /* opcional: cantos levemente arredondados */
  padding: 4px;             /* espaço interno */
}

.icon svg {
  width: 34px;              /* tamanho do ícone */
  height: 34px;
                /* preenchimento preto */
}
</style>
</head>
<body>
<script>
  window.onload = function() {
    setTimeout(function() {
      var splash = document.getElementById("splashScreen");
      if (splash) {
        splash.style.display = "none";
      }
    }, 30000);
  };
</script>
 <script>
window.addEventListener("load", function() {
  const splash = document.getElementById("splashScreen");
  const pin = document.getElementById("pinOverlay");
  const pinCheckbox = document.getElementById("pinEnabled");

  // Mostra o splash primeiro
  splash.style.display = "flex";

  // Depois de 3s, esconde o splash
  setTimeout(() => {
    splash.style.display = "none";

    // Só mostra o PIN se o checkbox estiver marcado
    if (pinCheckbox && pinCheckbox.checked) {
      pin.style.display = "flex";
    }
  }, 30000); // tempo do splash
});
</script>
<div  class="splash-screen" id="splashScreen">
  <div class="splash-logo">💬</div>
  <div class="splash-title">Bate-papo</div>
  <div class="splash-subtitle">  Carregando suas mensagens </div>
  <div class="splash-loader"></div>
  <div class="splash-status" id="splashStatus">Iniciando aplicação...</div>
</div>

<!-- PIN Security -->
<div class="pin-overlay" id="pinOverlay">
  <div class="pin-modal">
    <div class="pin-title"> Segurança</div>
    <div class="pin-subtitle" id="pinSubtitle">Digite seu PIN de 4 dígitos</div>
    <div class="pin-input">
      <input type="password" class="pin-digit" maxlength="1" data-index="0">
      <input type="password" class="pin-digit" maxlength="1" data-index="1">
      <input type="password" class="pin-digit" maxlength="1" data-index="2">
      <input type="password" class="pin-digit" maxlength="1" data-index="3">
    </div>
    <div class="pin-buttons">
      <button class="pin-btn secondary" id="pinCancel">Cancelar</button>
      <button class="pin-btn primary" id="pinConfirm">Confirmar</button>
    </div>
    <div class="pin-error" id="pinError">PIN incorreto. Tente novamente.</div>
  </div>
</div>

<div class="toast-container" id="toastContainer"></div>

<!-- Botão oculto para notificações Android -->
<button id="btnNotif" onclick="Android.showNotification()" style="display:none;"></button>

<div id="app">
  <aside class="sidebar">
    <div class="topbar">     
      <div class="me">
        <img src="" id="meAvatar" class="avatar" alt="Meu Avatar" onclick="openAvatarViewer(this.src, document.getElementById('meName').textContent)">
        <div class="info">
          <div id="meName" class="name">Carregando...</div>
          <div id="meEmail" class="email">—</div>
        </div>
      </div>
      <div class="actions">
        <button id="btnEdit" title="Editar Perfil"><!-- Chat seguro com fundo branco (48x48) -->
<span class="icon" aria-hidden="true">
 <!-- Cadeado com fundo branco e ícone preto -->
<svg width="20" height="20" viewBox="0 0 24 24"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Cadeado">
  <title>Cadeado</title>
  <!-- Fundo branco -->
  <rect width="24" height="24" fill="white"/>
  <!-- Corpo do cadeado -->
  <rect x="5.5" y="10" width="13" height="8.5" rx="1.8"
        stroke="black" stroke-width="1.8" fill="none"/>
  <!-- Arco do cadeado -->
  <path d="M8.5 10V8a3.5 3.5 0 0 1 7 0v2"
        stroke="black" stroke-width="1.8" stroke-linecap="round" fill="none"/>
  <!-- Miolo -->
  <circle cx="12" cy="14.5" r="0.9" fill="black"/>
</svg>
</span></button>
        <button id="btnBlocked" title="Usuários Bloqueados"><!-- Ícone alternativo de perfil bloqueado com fundo branco -->
<span class="icon" aria-hidden="true">
  <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"
       role="img" aria-label="Perfil bloqueado">
    <title>Perfil bloqueado</title>
    <!-- Fundo branco -->
    <rect width="50" height="50" fill="#FFFFFF" rx="8"/>

    <!-- Silhueta do perfil -->
    <circle cx="18" cy="18" r="6" stroke="#000000" stroke-width="2" fill="none"/>
    <path d="M8 36c0-5.5 4.5-10 10-10s10 4.5 10 10" 
          stroke="#000000" stroke-width="2" fill="none" stroke-linecap="round"/>

    <!-- Cadeado ao lado -->
    <rect x="28" y="22" width="10" height="7" rx="1.5"
          stroke="#000000" stroke-width="2" fill="none"/>
    <path d="M31 22v-2a3 3 0 1 1 6 0v2" 
          stroke="#000000" stroke-width="2" fill="none" stroke-linecap="round"/>
    <circle cx="33" cy="25.5" r="1" fill="#000000"/>
  </svg>
</span></button>
        <button style="display:none;" id="btnLogout" title="Sair">🚪</button>
      </div>
    </div>

    <!-- Tabs Navigation -->
    <div class="tabs-nav">
      <button class="tab-btn active" data-tab="my-chats">Meus Chats</button>
      <button class="tab-btn" data-tab="all-friends">Todos Amigos</button>
    </div>

    <!-- Tab: Meus Chats -->
    <div class="tab-content active" id="my-chats">
      <div class="search">
        <input id="searchChats" placeholder="Pesquisar conversas..." />
      </div>
      <ul id="chatList" class="user-list"></ul>
    </div>

    <!-- Tab: Todos Amigos -->
    <div class="tab-content" id="all-friends">
      <div class="search">
        <input id="searchFriends" placeholder="Pesquisar amigos..." />
      </div>
      <ul id="friendsList" class="user-list"></ul>
    </div>
  </aside>

  <section class="chat">
    <header class="chat-header">
      <button class="chat-back" id="chatBack" title="Voltar">←</button>
      <img id="chatAvatar" class="avatar" alt="Avatar do contato" onclick="openAvatarViewer(this.src, document.getElementById('chatName').textContent)">
      <div class="title">
        <div id="chatName" class="name">Selecione um usuário</div>
        <div class="status">
          <span id="chatDot" class="dot offline"></span>
          <span id="chatStatus">—</span>
        </div>
      </div>
      <div class="chat-actions">
        <button id="blockBtn" class="chat-btn block" style="display:none">🚫 Bloquear</button>
        <button id="unblockBtn" class="chat-btn unblock" style="display:none">✅ Desbloquear</button>
      </div>
    </header>
    <div id="messages" class="messages"></div>
    <div id="composer" class="composer">
      <button id="btnImage" title="Enviar imagem"><!-- Ícone de imagem com fundo branco -->
<!-- Ícone de imagem transparente (herda a cor via currentColor) -->
<span class="icon" aria-hidden="true" style="color:#fff">
  <!-- Ícone de imagem com fundo branco e ícone preto -->
<svg width="24" height="24" viewBox="0 0 24 24"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Imagem">
  <title>Imagem</title>
  <!-- Fundo branco -->
  <rect width="24" height="24" fill="white"/>
  <!-- Moldura -->
  <rect x="3" y="5" width="18" height="14" rx="2"
        stroke="black" stroke-width="1.8" fill="none"/>
  <!-- Montanha -->
  <path d="M5 15l4-4 4 4 4-5 4 5"
        stroke="black" stroke-width="1.8" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
  <!-- Sol -->
  <circle cx="9" cy="9" r="1.5" fill="black"/>
</svg>
</span></button>
      <button id="btnVideo" title="Enviar vídeo"><!-- Ícone de vídeo com fundo branco -->
<span class="icon" aria-hidden="true" style="color:#fff">
<svg width="24" height="24" viewBox="0 0 24 24"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Vídeo">
  <title>Vídeo</title>
  <!-- Fundo branco -->
  <rect width="24" height="24" fill="white"/>
  <!-- Câmera -->
  <rect x="3" y="6" width="14" height="10" rx="2"
        stroke="black" stroke-width="1.8" fill="none"/>
  <!-- Lente -->
  <path d="M17 8l3-2v8l-3-2"
        stroke="black" stroke-width="1.8" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
  <!-- Play button -->
  <path d="M9 9l3 2-3 2z"
        fill="black"/>
</svg>
</span></button>
      <input id="imageInput" type="file" accept="image/*" class="hidden" />
      <textarea id="textInput" rows="1" placeholder="Digite uma mensagem"></textarea>
      <button style="
  background-color: white;
  color: black;
  border: none;" id="btnSend"><!-- Ícone de enviar mensagem com fundo branco e ícone preto -->
<!-- Ícone de enviar mensagem (avião de papel) com fundo branco e ícone preto -->
<svg width="34" height="34" viewBox="0 0 24 24"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Enviar mensagem">
  <title>Enviar mensagem</title>
  <!-- Fundo branco -->
  <rect width="24" height="24" fill="white"/>
  <!-- Avião de papel -->
  <path d="M3 20L21 12L3 4V10L15 12L3 14V20Z"
        fill="black"/>
</svg></button>
    </div>
  </section>
</div>

<div id="viewer" class="viewer">
  <img id="viewerImg" alt="">
  <button class="viewer-close" id="viewerClose">Fechar</button>
</div>

<!-- Avatar Viewer -->
<div id="avatarViewer" class="avatar-viewer">
  <img id="avatarViewerImg" alt="">
  <button class="avatar-viewer-close" id="avatarViewerClose">×</button>
  <div class="avatar-viewer-name" id="avatarViewerName"></div>
</div>

<!-- Video URL Modal -->
<div id="videoModal" class="video-modal">
  <div class="video-modal-card">
    <h3>Adicionar Vídeo</h3>
    <p class="help">Cole a URL do vídeo (YouTube, Vimeo, etc.)</p>
    <input id="videoUrlInput" type="url" placeholder="https://www.youtube.com/watch?v=..." />
    <div class="video-modal-buttons">
      <button class="video-modal-btn secondary" id="videoCancelBtn">Cancelar</button>
      <button class="video-modal-btn primary" id="videoSendBtn">Enviar</button>
    </div>
  </div>
</div>

<div id="auth" class="auth">
  <div style="display:none;"  class="auth-card">
    <h2>Entrar</h2>
    <p class="help">Use a sessão existente ou entre agora.</p>
    <div class="row-line">
      <button id="btnGoogle" style="background:#ea4335">Google</button>
      <button id="btnAnon">Anônimo</button>
    </div>
    <p class="help">Após entrar, você poderá definir nome e foto.</p>
  </div>
</div>

<div id="profile" class="profile">
  <div class="profile-card">    
      <input style="display:none;" id="pName" placeholder="Seu nome" />
    <div class="row-line">
      <div style="display:none">
        <label>Foto (URL)</label>
        <input style="display:none;" id="pAvatar" placeholder="https://..." />
      </div>
      <div>
        <label style="display:none;">Adicione sua foto</label>
        <input style="display:none;" id="pFile" type="file" accept="image/*" />
      </div>
    </div>
    <div style="display:none;" class="help">A foto pode ser enviada e hospedada automaticamente.</div>
    
    <!-- PIN Settings -->
    <div class="pin-settings">
      <div class="pin-toggle">
        <input type="checkbox" id="pinEnabled">
        <label for="pinEnabled">Ativar PIN de segurança</label>
      </div>
      <div class="help">Protege o acesso ao suas conversas com um PIN de 4 dígitos</div>
      <div id="pinSetup" style="display:none;">
        <label>Novo PIN (4 dígitos)</label>
        <input id="newPin" type="password" maxlength="4" placeholder="••••" />
      </div>
    </div>
    
    <div class="row-line">
      <button id="pSave" style="
  background-color: #10b981; /* verde */
  color: white;
  border: none;
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
">
  Salvar
</button>

<button id="pClose" style="
  background-color: #6b7280; /* cinza */
  color: white;
  border: none;
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
">
  Fechar
</button>  </div>
  </div>
</div>

<div id="blockedModal" class="blocked-modal">
  <div class="blocked-card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">
      <h3>Usuários Bloqueados</h3>
      <button id="closeBlockedModal" style="background:none;border:none;font-size:20px;cursor:pointer;color:var(--text)">×</button>
    </div>
    <div class="blocked-list" id="blockedList">
    </div>
    <p class="help">Usuários bloqueados não aparecem na sua lista de contatos e não podem enviar mensagens para você.</p>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script>
const firebaseConfig = {
  apiKey: "AIzaSyCE_vGty5XsV1YqdCi49Ck2xJDSFq284wc",
  authDomain: "cliente-movicel.firebaseapp.com",
  databaseURL: "https://cliente-movicel-default-rtdb.firebaseio.com",
  projectId: "cliente-movicel",
  storageBucket: "cliente-movicel.firebasestorage.app",
  messagingSenderId: "215414688375",
  appId: "1:215414688375:web:2c7d20a0c03c4c0fcfd472",
  measurementId: "G-7F1RGP9GHV"
};

const IMGBB_KEY = "e073e02267a1f0259cd69c562e780659";

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

let me = null;
let meProfile = null;
let currentChat = null;
let currentChatUser = null;
let userStatusCache = {};
let userPreviewCache = {};
let usersCache = {};
let blockedUsers = {};
let messageStatusCache = {};
let friendsInChat = {}; // Lista de amigos que estão no chat
let currentTab = 'my-chats';

// Avatar Cache System
let avatarCache = {};

// Loading state management
let loadingState = {
  auth: false,
  profile: false,
  users: false,
  statuses: false,
  previews: false,
  blocked: false,
  friends: false
};

const el = (id)=>document.getElementById(id);
const splashScreen = el("splashScreen");
const splashStatus = el("splashStatus");
const pinOverlay = el("pinOverlay");
const pinSubtitle = el("pinSubtitle");
const pinDigits = document.querySelectorAll(".pin-digit");
const pinCancel = el("pinCancel");
const pinConfirm = el("pinConfirm");
const pinError = el("pinError");
const meAvatar = el("meAvatar");
const meName = el("meName");
const meEmail = el("meEmail");
const chatList = el("chatList");
const friendsList = el("friendsList");
const searchChats = el("searchChats");
const searchFriends = el("searchFriends");
const chatBack = el("chatBack");
const chatAvatar = el("chatAvatar");
const chatName = el("chatName");
const chatStatus = el("chatStatus");
const chatDot = el("chatDot");
const messagesEl = el("messages");
const composer = el("composer");
const textInput = el("textInput");
const btnSend = el("btnSend");
const btnImage = el("btnImage");
const btnVideo = el("btnVideo");
const imageInput = el("imageInput");
const viewer = el("viewer");
const viewerImg = el("viewerImg");
const viewerClose = el("viewerClose");
const avatarViewer = el("avatarViewer");
const avatarViewerImg = el("avatarViewerImg");
const avatarViewerClose = el("avatarViewerClose");
const avatarViewerName = el("avatarViewerName");
const videoModal = el("videoModal");
const videoUrlInput = el("videoUrlInput");
const videoCancelBtn = el("videoCancelBtn");
const videoSendBtn = el("videoSendBtn");
const authModal = el("auth");
const btnGoogle = el("btnGoogle");
const btnAnon = el("btnAnon");
const profileModal = el("profile");
const pName = el("pName");
const pAvatar = el("pAvatar");
const pFile = el("pFile");
const pSave = el("pSave");
const pClose = el("pClose");
const btnEdit = el("btnEdit");
const btnLogout = el("btnLogout");
const toastContainer = el("toastContainer");
const btnBlocked = el("btnBlocked");
const blockedModal = el("blockedModal");
const closeBlockedModal = el("closeBlockedModal");
const blockedList = el("blockedList");
const blockBtn = el("blockBtn");
const unblockBtn = el("unblockBtn");
const pinEnabled = el("pinEnabled");
const pinSetup = el("pinSetup");
const newPin = el("newPin");
const btnNotif = el("btnNotif");

// Avatar Cache Management
function loadAvatarCache() {
  try {
    const cached = localStorage.getItem('chatAvatarCache');
    if (cached) {
      avatarCache = JSON.parse(cached);
      console.log('📸 Avatar cache carregado:', Object.keys(avatarCache).length);
    }
  } catch (error) {
    console.error('Erro ao carregar cache de avatares:', error);
    avatarCache = {};
  }
}

function saveAvatarCache() {
  try {
    localStorage.setItem('chatAvatarCache', JSON.stringify(avatarCache));
  } catch (error) {
    console.error('Erro ao salvar cache de avatares:', error);
  }
}

function cacheAvatar(userId, avatarUrl) {
  if (avatarUrl && avatarUrl.trim() && !avatarUrl.includes('data:image/svg')) {
    avatarCache[userId] = {
      url: avatarUrl,
      timestamp: Date.now()
    };
    saveAvatarCache();
  }
}

function getCachedAvatar(userId) {
  const cached = avatarCache[userId];
  if (cached) {
    // Cache válido por 24 horas
    const isValid = (Date.now() - cached.timestamp) < (24 * 60 * 60 * 1000);
    if (isValid) {
      return cached.url;
    } else {
      delete avatarCache[userId];
      saveAvatarCache();
    }
  }
  return null;
}

function clearAvatarCache() {
  avatarCache = {};
  localStorage.removeItem('chatAvatarCache');
  showToast('Cache de avatares limpo', 'info');
}

// Video URL Processing
function processVideoUrl(url) {
  if (!url) return null;
  
  // YouTube
  let youtubeMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/);
  if (youtubeMatch) {
    return `https://www.youtube.com/embed/${youtubeMatch[1]}?rel=0&modestbranding=1`;
  }
  
  // Vimeo
  let vimeoMatch = url.match(/(?:vimeo\.com\/)([0-9]+)/);
  if (vimeoMatch) {
    return `https://player.vimeo.com/video/${vimeoMatch[1]}`;
  }
  
  // Dailymotion
  let dailymotionMatch = url.match(/(?:dailymotion\.com\/video\/)([^&\n?#]+)/);
  if (dailymotionMatch) {
    return `https://www.dailymotion.com/embed/video/${dailymotionMatch[1]}`;
  }
  
  // Direct video URLs
  if (url.match(/\.(mp4|webm|ogg)(\?.*)?$/i)) {
    return url;
  }
  
  return null;
}

function isValidVideoUrl(url) {
  return processVideoUrl(url) !== null;
}

// Tab Navigation
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.onclick = () => switchTab(btn.dataset.tab);
});

function switchTab(tabName) {
  currentTab = tabName;
  
  // Update tab buttons
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tabName);
  });
  
  // Update tab content
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.toggle('active', content.id === tabName);
  });
  
  // Clear search when switching tabs
  if (tabName === 'my-chats') {
    searchChats.value = '';
    filterChatList();
  } else {
    searchFriends.value = '';
    filterFriendsList();
  }
}

// Avatar Viewer Functions
function openAvatarViewer(src, name) {
  if (!src || src.includes('data:image/svg')) return;
  
  avatarViewerImg.src = src;
  avatarViewerName.textContent = name || 'Usuário';
  avatarViewer.style.display = 'flex';
}

avatarViewerClose.onclick = () => {
  avatarViewer.style.display = 'none';
  avatarViewerImg.src = '';
};

avatarViewer.onclick = (e) => {
  if (e.target === avatarViewer) {
    avatarViewer.style.display = 'none';
    avatarViewerImg.src = '';
  }
};

// Video Modal Functions
btnVideo.onclick = () => {
  videoModal.style.display = 'flex';
  videoUrlInput.focus();
};

videoCancelBtn.onclick = () => {
  videoModal.style.display = 'none';
  videoUrlInput.value = '';
};

videoSendBtn.onclick = () => {
  const url = videoUrlInput.value.trim();
  if (!url) {
    showToast('Digite uma URL de vídeo', 'error');
    return;
  }
  
  if (!isValidVideoUrl(url)) {
    showToast('URL de vídeo não suportada. Use YouTube, Vimeo ou links diretos.', 'error');
    return;
  }
  
  if (!currentChat) {
    showToast('Selecione um usuário para enviar o vídeo', 'error');
    return;
  }
  
  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  sendMessage({type: "video", url: url, id: messageId});
  
  videoModal.style.display = 'none';
  videoUrlInput.value = '';
  showToast('Vídeo enviado! 🎥', 'success');
};

videoModal.onclick = (e) => {
  if (e.target === videoModal) {
    videoModal.style.display = 'none';
    videoUrlInput.value = '';
  }
};

// Enter key in video URL input
videoUrlInput.onkeydown = (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    videoSendBtn.click();
  }
};

// Update splash status
function updateSplashStatus(message) {
  splashStatus.textContent = message;
  console.log('📍 Loading:', message);
}

// Check if all data is loaded
function checkAllDataLoaded() {
  const allLoaded = Object.values(loadingState).every(state => state);
  console.log('📊 Loading state:', loadingState, 'All loaded:', allLoaded);
  
  if (allLoaded) {
    updateSplashStatus('Tudo pronto! Abrindo aplicação...');
    setTimeout(() => {
      hideSplashScreen();
    }, 800);
  }
}

// PIN Security System
let appPin = localStorage.getItem('chatPin') || null;
let pinMode = 'verify'; // 'verify' or 'setup'
let currentPinInput = '';
let pinAuthenticated = false;

function initPinSystem() {
  const pinEnabledStored = localStorage.getItem('pinEnabled') === 'true';
  pinEnabled.checked = pinEnabledStored;
  
  pinEnabled.onchange = () => {
    if (pinEnabled.checked) {
      pinSetup.style.display = 'block';
    } else {
      pinSetup.style.display = 'none';
      localStorage.removeItem('chatPin');
      localStorage.removeItem('pinEnabled');
      appPin = null;
    }
  };
  
  // Check if PIN is required
  if (pinEnabledStored && appPin && !pinAuthenticated) {
    // Wait for splash to finish, then show PIN
    setTimeout(() => {
      if (Object.values(loadingState).every(state => state)) {
        showPinOverlay('verify');
      }
    }, 2000);
  }
}

function showPinOverlay(mode) {
  pinMode = mode;
  currentPinInput = '';
  
  if (mode === 'verify') {
    pinSubtitle.textContent = 'Digite seu PIN para acessar o app';
  } else {
    pinSubtitle.textContent = 'Defina um PIN de 4 dígitos';
  }
  
  pinDigits.forEach(digit => {
    digit.value = '';
    digit.classList.remove('filled');
  });
  
  pinError.style.display = 'none';
  pinOverlay.style.display = 'flex';
  pinDigits[0].focus();
}

function hidePinOverlay() {
  pinOverlay.style.display = 'none';
  pinAuthenticated = true;
  
  // If PIN was being verified and is now authenticated, ensure splash is hidden
  if (pinMode === 'verify' && Object.values(loadingState).every(state => state)) {
    hideSplashScreen();
  }
}

// PIN input handling
pinDigits.forEach((digit, index) => {
  digit.oninput = (e) => {
    const value = e.target.value;
    if (value && /^\d$/.test(value)) {
      digit.classList.add('filled');
      if (index < 3) {
        pinDigits[index + 1].focus();
      }
      updatePinInput();
    }
  };
  
  digit.onkeydown = (e) => {
    if (e.key === 'Backspace' && !digit.value && index > 0) {
      pinDigits[index - 1].focus();
      pinDigits[index - 1].value = '';
      pinDigits[index - 1].classList.remove('filled');
      updatePinInput();
    }
  };
});

function updatePinInput() {
  currentPinInput = Array.from(pinDigits).map(d => d.value).join('');
  if (currentPinInput.length === 4) {
    if (pinMode === 'verify') {
      verifyPin();
    }
  }
}

function verifyPin() {
  if (currentPinInput === appPin) {
    hidePinOverlay();
  } else {
    showPinError();
  }
}

function showPinError() {
  pinError.style.display = 'block';
  pinDigits.forEach(digit => {
    digit.value = '';
    digit.classList.remove('filled');
  });
  currentPinInput = '';
  pinDigits[0].focus();
}

pinConfirm.onclick = () => {
  if (currentPinInput.length === 4) {
    if (pinMode === 'verify') {
      verifyPin();
    }
  }
};

pinCancel.onclick = () => {
  if (pinMode === 'verify') {
    // Force reload if user cancels PIN verification
    location.reload();
  } else {
    hidePinOverlay();
  }
};

// Splash Screen
function hideSplashScreen() {
  // Only hide if PIN is not required or is authenticated
  const pinRequired = localStorage.getItem('pinEnabled') === 'true' && appPin;
  
  if (!pinRequired || pinAuthenticated) {
    splashScreen.classList.add('hidden');
    document.body.style.overflow = 'auto';
    console.log('🎉 App ready and splash hidden');
  }
}

// Sistema de notificação para Android
function triggerAndroidNotification() {
  try {
    if (btnNotif && typeof btnNotif.click === 'function') {
      btnNotif.click();
      console.log('🔔 Notificação Android disparada');
    }
  } catch (error) {
    console.log('Notificação Android não disponível:', error);
  }
}

// Sistema de notificação sonora usando Web Audio API
function createNotificationSound(frequency, duration) {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    oscillator.type = 'sine';
    
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
  } catch (error) {
    console.log('Audio notification not available');
  }
}

// Sistema de Toast
function showToast(message, type = 'info', duration = 3000) {
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.textContent = message;
  toastContainer.appendChild(toast);
  
  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease forwards';
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

// Dark mode
if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
  document.body.classList.add('dark');
}

window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
  if (event.matches) {
    document.body.classList.add('dark');
  } else {
    document.body.classList.remove('dark');
  }
});

// Função para gerar avatar com iniciais
function getDefaultAvatar(name) {
  const initials = (name || "U").split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
  const colors = ['#1a73e8', '#34a853', '#ea4335', '#fbbc04', '#9c27b0', '#ff5722', '#607d8b', '#795548'];
  const colorIndex = (name || "U").charCodeAt(0) % colors.length;
  const color = colors[colorIndex];
  
  return `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'><circle cx='32' cy='32' r='32' fill='${encodeURIComponent(color)}'/><text x='32' y='38' text-anchor='middle' fill='white' font-family='Arial,sans-serif' font-size='20' font-weight='bold'>${encodeURIComponent(initials)}</text></svg>`;
}

// Função para carregar avatar com cache e fallback robusto
function loadAvatar(imgElement, avatarUrl, userName, userId = null) {
  if (!imgElement) return;
  
  // Reset element state
  imgElement.classList.remove('loaded');
  imgElement.textContent = '';
  
  // Try to get from cache first
  let urlToUse = avatarUrl;
  if (userId) {
    const cachedUrl = getCachedAvatar(userId);
    if (cachedUrl) {
      urlToUse = cachedUrl;
    }
  }
  
  if (urlToUse && urlToUse.trim() && urlToUse !== 'null' && urlToUse !== 'undefined' && !urlToUse.includes('data:image/svg')) {
    const testImg = new Image();
    
    testImg.onload = () => {
      imgElement.src = urlToUse;
      imgElement.classList.add('loaded');
      // Cache the successful URL
      if (userId && urlToUse === avatarUrl) {
        cacheAvatar(userId, avatarUrl);
      }
    };
    
    testImg.onerror = () => {
      // If cached URL fails, try original URL if different
      if (urlToUse !== avatarUrl && avatarUrl && avatarUrl.trim()) {
        const retryImg = new Image();
        retryImg.onload = () => {
          imgElement.src = avatarUrl;
          imgElement.classList.add('loaded');
          cacheAvatar(userId, avatarUrl);
        };
        retryImg.onerror = () => {
          setAvatarWithInitials(imgElement, userName);
        };
        retryImg.src = avatarUrl;
      } else {
        setAvatarWithInitials(imgElement, userName);
      }
    };
    
    testImg.src = urlToUse;
  } else {
    setAvatarWithInitials(imgElement, userName);
  }
}

function setAvatarWithInitials(imgElement, userName) {
  const initials = (userName || "U").split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
  imgElement.src = getDefaultAvatar(userName);
  imgElement.classList.add('loaded');
  imgElement.onerror = () => {
    imgElement.style.display = 'flex';
    imgElement.textContent = initials;
    imgElement.src = '';
  };
}

// Upload de imagem
async function uploadToImgBB(file) {
  try {
    const formData = new FormData();
    formData.append('image', file);
    
    const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_KEY}`, {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }
    
    const data = await response.json();
    if (data.success) {
      return data.data.url;
    } else {
      throw new Error(data.error?.message || 'Falha no upload');
    }
  } catch (error) {
    console.error('Erro no upload ImgBB:', error);
    throw error;
  }
}

// Friends Management System
async function addFriendToChat(userId) {
  try {
    await db.ref(`friendsInChat/${me.uid}/${userId}`).set(true);
    friendsInChat[userId] = true;
    showToast('Amigo adicionado ao chat! 👥', 'success');
    renderChatList();
    renderFriendsList();
  } catch (error) {
    console.error('Erro ao adicionar amigo ao chat:', error);
    showToast('Erro ao adicionar amigo', 'error');
  }
}

async function removeFriendFromChat(userId) {
  try {
    await db.ref(`friendsInChat/${me.uid}/${userId}`).remove();
    delete friendsInChat[userId];
    showToast('Amigo removido do chat', 'info');
    renderChatList();
    renderFriendsList();
  } catch (error) {
    console.error('Erro ao remover amigo do chat:', error);
    showToast('Erro ao remover amigo', 'error');
  }
}

function isFriendInChat(userId) {
  return friendsInChat && friendsInChat[userId] === true;
}

// Função para verificar se usuário está bloqueado
function isUserBlocked(userId) {
  return blockedUsers && blockedUsers[userId] === true;
}

// Função para bloquear usuário
async function blockUser(userId) {
  try {
    await db.ref(`blocked/${me.uid}/${userId}`).set(true);
    blockedUsers[userId] = true;
    showToast('Usuário bloqueado com sucesso', 'success');
    renderChatList();
    renderFriendsList();
    updateBlockButtons();
  } catch (error) {
    console.error('Erro ao bloquear usuário:', error);
    showToast('Erro ao bloquear usuário', 'error');
  }
}

// Função para desbloquear usuário
async function unblockUser(userId) {
  try {
    await db.ref(`blocked/${me.uid}/${userId}`).remove();
    delete blockedUsers[userId];
    showToast('Usuário desbloqueado com sucesso', 'success');
    renderChatList();
    renderFriendsList();
    updateBlockButtons();
    renderBlockedUsers();
  } catch (error) {
    console.error('Erro ao desbloquear usuário:', error);
    showToast('Erro ao desbloquear usuário', 'error');
  }
}

// Função para mostrar modal de confirmação personalizado
function showConfirmDialog(message, onConfirm) {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1400;
    backdrop-filter: blur(4px);
  `;
  
  modal.innerHTML = `
    <div style="
      background: var(--card);
      border-radius: 16px;
      padding: 24px;
      max-width: 400px;
      width: calc(100% - 40px);
      box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3);
    ">
      <p style="
        color: var(--text);
        margin: 0 0 20px 0;
        font-size: 16px;
        line-height: 1.5;
      ">${message}</p>
      <div style="
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      ">
        <button id="cancelBtn" style="
          padding: 10px 20px;
          border: 1px solid var(--line);
          background: transparent;
          color: var(--text);
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
          transition: all 0.2s ease;
        ">Cancelar</button>
        <button id="confirmBtn" style="
          padding: 10px 20px;
          background: #ef4444;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
          transition: all 0.2s ease;
        ">Confirmar</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Event listeners
  modal.querySelector('#cancelBtn').onclick = () => {
    document.body.removeChild(modal);
  };
  
  modal.querySelector('#confirmBtn').onclick = () => {
    document.body.removeChild(modal);
    onConfirm();
  };
  
  // Fechar clicando fora
  modal.onclick = (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  };
}

// Atualizar botões de bloquear/desbloquear
function updateBlockButtons() {
  if (currentChatUser) {
    const isBlocked = isUserBlocked(currentChatUser.uid);
    blockBtn.style.display = isBlocked ? 'none' : 'block';
    unblockBtn.style.display = isBlocked ? 'block' : 'none';
  } else {
    blockBtn.style.display = 'none';
    unblockBtn.style.display = 'none';
  }
}

// Renderizar lista de usuários bloqueados
function renderBlockedUsers() {
  blockedList.innerHTML = '';
  
  const blockedUserIds = Object.keys(blockedUsers).filter(uid => blockedUsers[uid]);
  
  if (blockedUserIds.length === 0) {
    blockedList.innerHTML = '<p style="text-align:center;color:var(--muted);padding:20px">Nenhum usuário bloqueado</p>';
    return;
  }
  
  blockedUserIds.forEach(userId => {
    const user = usersCache[userId];
    if (!user) return;
    
    const item = document.createElement('div');
    item.className = 'blocked-item';
    
    const avatar = document.createElement('img');
    avatar.className = 'avatar';
    loadAvatar(avatar, user.avatar, user.name, userId);
    
    const info = document.createElement('div');
    info.className = 'info';
    
    const name = document.createElement('div');
    name.className = 'name';
    name.textContent = user.name || 'Usuário';
    
    const email = document.createElement('div');
    email.className = 'email';
    email.textContent = user.email || 'Email não disponível';
    
    info.appendChild(name);
    info.appendChild(email);
    
    const unblockButton = document.createElement('button');
    unblockButton.className = 'unblock-btn';
    unblockButton.textContent = 'Desbloquear';
    unblockButton.onclick = () => unblockUser(userId);
    
    item.appendChild(avatar);
    item.appendChild(info);
    item.appendChild(unblockButton);
    
    blockedList.appendChild(item);
  });
}

// Message Status System
function updateMessageStatus(messageId, status) {
  messageStatusCache[messageId] = status;
  
  // Update UI
  const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
  if (messageElement) {
    const statusElement = messageElement.querySelector('.message-status');
    if (statusElement) {
      statusElement.className = `message-status ${status}`;
      statusElement.textContent = getStatusIcon(status);
    }
  }
}

function getStatusIcon(status) {
  switch (status) {
    case 'sent': return '✓';
    case 'delivered': return '✓✓';
    case 'read': return '✓✓';
    default: return '';
  }
}

function goToHome() {
  document.querySelector('.sidebar').classList.add('active');
  document.querySelector('.chat').classList.remove('active');
  currentChat = null;
  currentChatUser = null;
  composer.style.display = 'none';
  chatName.textContent = 'Selecione um usuário';
  chatStatus.textContent = '—';
  chatDot.className = 'dot offline';
  updateBlockButtons();
}

function now(){ return Date.now(); }
function chatId(a,b){ return a<b ? a+"_"+b : b+"_"+a; }
function formatTime(ts){
  try{
    const d=new Date(ts); 
    return d.toLocaleTimeString([], {hour:"2-digit",minute:"2-digit"});
  }catch{ return "" }
}
function linkify(text){
  return text.replace(/(https?:\/\/[^\s]+)/g,'<a class="link" href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
}

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
  updateSplashStatus('Iniciando sistema de segurança...');
  loadAvatarCache();
  initPinSystem();
});

auth.onAuthStateChanged(async user=>{
  if(user){
    me = user;
    loadingState.auth = true;
    authModal.style.display = "none";
    updateSplashStatus('Carregando perfil do usuário...');
    await ensureProfile();
    bindPresence();
    bindUsers();
    bindStatuses();
    bindPreviews();
    bindBlockedUsers();
    bindFriendsInChat();
    bindMessageStatus();
    checkAllDataLoaded();
  }else{
    authModal.style.display = "flex";
    splashScreen.classList.add('hidden');
  }
});

// Bind para amigos no chat
function bindFriendsInChat() {
  updateSplashStatus('Carregando lista de amigos...');
  db.ref(`friendsInChat/${me.uid}`).on('value', (snapshot) => {
    friendsInChat = snapshot.val() || {};
    loadingState.friends = true;
    console.log('👥 Amigos no chat carregados:', friendsInChat);
    renderChatList();
    renderFriendsList();
    checkAllDataLoaded();
  });
}

// Bind para usuários bloqueados
function bindBlockedUsers() {
  updateSplashStatus('Carregando usuários bloqueados...');
  db.ref(`blocked/${me.uid}`).on('value', (snapshot) => {
    blockedUsers = snapshot.val() || {};
    loadingState.blocked = true;
    console.log('Usuários bloqueados carregados:', blockedUsers);
    renderChatList();
    renderFriendsList();
    updateBlockButtons();
    checkAllDataLoaded();
  });
}

// Bind para status das mensagens
function bindMessageStatus() {
  db.ref(`messageStatus/${me.uid}`).on('value', (snapshot) => {
    const statuses = snapshot.val() || {};
    Object.keys(statuses).forEach(messageId => {
      updateMessageStatus(messageId, statuses[messageId]);
    });
  });
}

btnGoogle.onclick = async ()=>{
  try{
    updateSplashStatus('Conectando com Google...');
    const provider = new firebase.auth.GoogleAuthProvider();
    const result = await auth.signInWithPopup(provider);
    if(result.user && result.user.displayName && result.user.photoURL) {
      const userData = {
        name: result.user.displayName,
        avatar: result.user.photoURL,
        lastSeen: now()
      };
      await db.ref("users/"+result.user.uid).update(userData);
    }
  }catch(e){ 
    console.error("Erro no login Google:", e);
    showToast("Falha no login Google: "+e.message, 'error'); 
  }
};

btnAnon.onclick = async ()=>{
  try{ 
    updateSplashStatus('Conectando anonimamente...');
    await auth.signInAnonymously(); 
  }
  catch(e){ 
    console.error("Erro no login anônimo:", e);
    showToast("Falha no login anônimo: "+e.message, 'error'); 
  }
};

btnLogout.onclick = async()=>{ 
  await auth.signOut(); 
  location.reload(); 
};

btnEdit.onclick = ()=> openProfile();
pClose.onclick = ()=> profileModal.style.display = "none";
chatBack.onclick = ()=> goToHome();

// Event listeners para bloqueio
btnBlocked.onclick = () => {
  blockedModal.style.display = "flex";
  renderBlockedUsers();
};

closeBlockedModal.onclick = () => {
  blockedModal.style.display = "none";
};

blockBtn.onclick = () => {
  if (currentChatUser) {
    showConfirmDialog(`Tem certeza que deseja bloquear ${currentChatUser.name}?`, () => {
      blockUser(currentChatUser.uid);
    });
  }
};

unblockBtn.onclick = () => {
  if (currentChatUser) {
    showConfirmDialog(`Tem certeza que deseja desbloquear ${currentChatUser.name}?`, () => {
      unblockUser(currentChatUser.uid);
    });
  }
};

// Search functionality
searchChats.oninput = () => filterChatList();
searchFriends.oninput = () => filterFriendsList();

pFile.onchange = async (e)=>{
  const file = e.target.files[0]; 
  if(!file) return;
  
  if (file.size > 5 * 1024 * 1024) {
    showToast('Arquivo muito grande! Máximo 5MB.', 'error');
    return;
  }

  if (!file.type.startsWith('image/')) {
    showToast('Selecione apenas arquivos de imagem.', 'error');
    return;
  }
  
  try {
    showToast('Enviando foto...', 'info');
    const url = await uploadToImgBB(file);
    if(url){ 
      pAvatar.value = url;
      loadAvatar(meAvatar, url, pName.value || meProfile?.name || "Usuário", me.uid);
      showToast('Foto enviada com sucesso! 📸', 'success');
    }
  } catch(error) {
    console.error("Erro ao fazer upload:", error);
    showToast("Erro ao fazer upload da imagem", 'error');
  }
};

pSave.onclick = async ()=>{
  const name = pName.value.trim() || "Usuário";
  const avatar = pAvatar.value.trim();
  
  // Handle PIN setup
  if (pinEnabled.checked && newPin.value.trim()) {
    const pin = newPin.value.trim();
    if (pin.length === 4 && /^\d{4}$/.test(pin)) {
      localStorage.setItem('chatPin', pin);
      localStorage.setItem('pinEnabled', 'true');
      appPin = pin;
      pinAuthenticated = true; // Important: mark as authenticated when setting new PIN
      showToast('PIN definido com sucesso! 🔐', 'success');
    } else {
      showToast('PIN deve ter exatamente 4 dígitos', 'error');
      return;
    }
  } else if (!pinEnabled.checked) {
    localStorage.removeItem('chatPin');
    localStorage.removeItem('pinEnabled');
    appPin = null;
    pinAuthenticated = true; // No PIN required
  }
  
  try {
    const updates = { name, avatar, lastSeen: now() };
    await db.ref("users/"+me.uid).update(updates);
    
    await me.updateProfile({ 
      displayName: name, 
      photoURL: avatar || null 
    }).catch(()=>{});
    
    meProfile = {uid:me.uid, ...updates};
    
    // Cache the new avatar
    if (avatar) {
      cacheAvatar(me.uid, avatar);
    }
    
    renderMe();
    profileModal.style.display = "none";
    showToast("Perfil atualizado com sucesso!", 'success');
  } catch(error) {
    console.error("Erro ao salvar perfil:", error);
    showToast("Erro ao salvar perfil", 'error');
  }
};

async function ensureProfile(){
  try {
    const snap = await db.ref("users/"+me.uid).get();
    let profile = snap.val();
    
    if(!profile){
      profile = { 
        uid: me.uid, 
        name: me.displayName || "Usuário", 
        avatar: me.photoURL || "", 
        lastSeen: now() 
      };
      await db.ref("users/"+me.uid).set(profile);
    } else {
      const needsUpdate = {};
      if(me.displayName && me.displayName !== profile.name) {
        needsUpdate.name = me.displayName;
      }
      if(me.photoURL && me.photoURL !== profile.avatar) {
        needsUpdate.avatar = me.photoURL;
      }
      if(Object.keys(needsUpdate).length > 0) {
        needsUpdate.lastSeen = now();
        await db.ref("users/"+me.uid).update(needsUpdate);
        profile = {...profile, ...needsUpdate};
      }
    }
    
    meProfile = profile;
    loadingState.profile = true;
    
    // Cache my avatar
    if (profile.avatar) {
      cacheAvatar(me.uid, profile.avatar);
    }
    
    renderMe();
    
    if(me.displayName !== profile.name || me.photoURL !== (profile.avatar||"")){
      try{ 
        await me.updateProfile({
          displayName: profile.name, 
          photoURL: profile.avatar||null
        }); 
      }catch(e){
        console.warn("Erro ao atualizar auth profile:", e);
      }
    }
    
    if(!profile.name || profile.name==="Usuário"){ 
      openProfile(); 
    }
    
    checkAllDataLoaded();
  } catch(error) {
    console.error("Erro ao carregar perfil:", error);
    showToast("Erro ao carregar perfil", 'error');
  }
}

function renderMe(){
  if(!meProfile) return;
  
  loadAvatar(meAvatar, meProfile.avatar, meProfile.name, me.uid);
  meName.textContent = meProfile.name || "Usuário";
  meEmail.textContent = me.email || (me.isAnonymous ? "Conectado como Anônimo" : "—");
  pName.value = meProfile.name || "";
  pAvatar.value = meProfile.avatar || "";
}

function openProfile(){ 
  profileModal.style.display = "flex"; 
  if(meProfile) {
    pName.value = meProfile.name || "";
    pAvatar.value = meProfile.avatar || "";
  }
}

function bindPresence(){
  const statusRef = db.ref("status/"+me.uid);
  const isOffline = { 
    state: "offline", 
    lastSeen: firebase.database.ServerValue.TIMESTAMP,
    timestamp: firebase.database.ServerValue.TIMESTAMP 
  };
  const isOnline = { 
    state: "online", 
    lastSeen: firebase.database.ServerValue.TIMESTAMP,
    timestamp: firebase.database.ServerValue.TIMESTAMP 
  };
  
  db.ref(".info/connected").on("value", snap=>{
    if(snap.val() === true){
      console.log('📡 Conectado ao Firebase');
      statusRef.onDisconnect().set(isOffline).then(()=> {
        console.log('📡 OnDisconnect configurado');
        statusRef.set(isOnline).then(() => {
          console.log('📡 Status online definido');
        });
      });
    } else {
      console.log('📡 Desconectado do Firebase');
    }
  });
  
  setInterval(()=> {
    statusRef.update({ 
      lastSeen: firebase.database.ServerValue.TIMESTAMP,
      timestamp: firebase.database.ServerValue.TIMESTAMP 
    });
    db.ref("users/"+me.uid).update({ lastSeen: now() });
  }, 30_000);
}

function bindUsers(){
  updateSplashStatus('Carregando lista de usuários...');
  db.ref("users").on("value", snap=>{
    const all = snap.val() || {};
    usersCache = all;
    loadingState.users = true;
    console.log('👥 Usuários carregados:', Object.keys(all).length);
    
    // Cache all user avatars
    Object.keys(all).forEach(uid => {
      const user = all[uid];
      if (user.avatar) {
        cacheAvatar(uid, user.avatar);
      }
    });
    
    renderChatList();
    renderFriendsList();
    checkAllDataLoaded();
  });
}

function bindStatuses(){
  updateSplashStatus('Carregando status dos usuários...');
  db.ref("status").on("value", snap=>{
    const statuses = snap.val() || {};
    userStatusCache = statuses;
    loadingState.statuses = true;
    console.log('📊 Status carregados:', Object.keys(statuses).length);
    updateStatusIndicators();
    checkAllDataLoaded();
  });
}

function bindPreviews(){
  updateSplashStatus('Carregando preview das conversas...');
  db.ref("userChats/"+me.uid).on("value", snap=>{
    userPreviewCache = snap.val() || {};
    loadingState.previews = true;
    renderChatList();
    checkAllDataLoaded();
  });
}

// Render Chat List (only friends in chat)
function renderChatList() {
  chatList.innerHTML = "";
  
  const allUsers = Object.keys(usersCache)
    .filter(uid => uid !== me.uid)
    .map(uid => ({uid, ...usersCache[uid]}))
    .filter(user => user.name && user.name !== "");
  
  // Only show friends that are in chat and not blocked
  const chatUsers = allUsers.filter(user => 
    isFriendInChat(user.uid) && !isUserBlocked(user.uid)
  );
  
  chatUsers.sort((a,b)=>{
    const la = userPreviewCache?.[a.uid]?.lastTime || 0;
    const lb = userPreviewCache?.[b.uid]?.lastTime || 0;
    if(lb!==la) return lb-la;
    return (a.name||"").localeCompare(b.name||"");
  });
  
  if (chatUsers.length === 0) {
    chatList.innerHTML = '<p style="text-align:center;color:var(--muted);padding:20px">Nenhum amigo no chat ainda.<br>Adicione amigos na aba "Todos Amigos"</p>';
    return;
  }
  
  chatUsers.forEach(u => {
    createUserListItem(u, chatList, 'chat');
  });
  
  filterChatList();
  updateStatusIndicators();
}

// Render Friends List (all users with add/remove buttons)
function renderFriendsList() {
  friendsList.innerHTML = "";
  
  const allUsers = Object.keys(usersCache)
    .filter(uid => uid !== me.uid)
    .map(uid => ({uid, ...usersCache[uid]}))
    .filter(user => user.name && user.name !== "");
  
  // Show all users except blocked ones
  const availableUsers = allUsers.filter(user => !isUserBlocked(user.uid));
  
  availableUsers.sort((a,b) => {
    return (a.name||"").localeCompare(b.name||"");
  });
  
  if (availableUsers.length === 0) {
    friendsList.innerHTML = '<p style="text-align:center;color:var(--muted);padding:20px">Nenhum usuário disponível</p>';
    return;
  }
  
  availableUsers.forEach(u => {
    createUserListItem(u, friendsList, 'friends');
  });
  
  filterFriendsList();
  updateStatusIndicators();
}

function createUserListItem(user, container, listType) {
  const li = document.createElement("li");
  li.className = "user-item";
  li.dataset.uid = user.uid;

  const img = document.createElement("img");
  img.className = "avatar";
  img.alt = user.name || "Usuário";
  img.onclick = (e) => {
    e.stopPropagation();
    openAvatarViewer(user.avatar, user.name);
  };
  loadAvatar(img, user.avatar, user.name, user.uid);

  const main = document.createElement("div");
  main.className = "u-main";
  const nm = document.createElement("div"); 
  nm.className = "u-name"; 
  nm.textContent = user.name || "Sem nome";
  
  const pv = document.createElement("div"); 
  pv.className = "u-preview";
  
  if (listType === 'chat') {
    const preview = userPreviewCache?.[user.uid]?.lastText || "";
    pv.innerHTML = preview ? sanitizePreview(preview) : "Nenhuma mensagem ainda";
  } else {
    pv.textContent = user.email || "Usuário disponível";
  }

  main.appendChild(nm); 
  main.appendChild(pv);

  const right = document.createElement("div");
  right.className = "u-right";
  
  if (listType === 'chat') {
    const time = document.createElement("div");
    time.className = "u-time";
    time.textContent = userPreviewCache?.[user.uid]?.lastTime ? 
      formatTime(userPreviewCache?.[user.uid]?.lastTime) : "";
    
    const dot = document.createElement("div");
    const userStatus = userStatusCache?.[user.uid];
    dot.className = "dot " + (userStatus?.state==="online" ? "online":"offline");
    
    right.appendChild(time); 
    right.appendChild(dot);
    
    li.onclick = () => openChat(user.uid, user);
  } else {
    // Friends list - show add/remove button
    const actionBtn = document.createElement("button");
    actionBtn.className = "friend-action";
    
    if (isFriendInChat(user.uid)) {
      actionBtn.textContent = "Remover";
      actionBtn.classList.add("remove");
      actionBtn.onclick = (e) => {
        e.stopPropagation();
        removeFriendFromChat(user.uid);
      };
    } else {
      actionBtn.textContent = "Adicionar";
      actionBtn.onclick = (e) => {
        e.stopPropagation();
        addFriendToChat(user.uid);
      };
    }
    
    const dot = document.createElement("div");
    const userStatus = userStatusCache?.[user.uid];
    dot.className = "dot " + (userStatus?.state==="online" ? "online":"offline");
    
    right.appendChild(actionBtn);
    right.appendChild(dot);
  }

  li.appendChild(img); 
  li.appendChild(main); 
  li.appendChild(right);
  container.appendChild(li);
}

function sanitizePreview(t){
  const div = document.createElement("div"); 
  div.innerText = t; 
  let s = div.innerText;
  if(s.length>40) s = s.slice(0,40)+"…";
  return s;
}

function filterChatList(){
  const q = (searchChats.value||"").toLowerCase().trim();
  [...chatList.children].forEach(li=>{
    if (li.tagName !== 'LI') return;
    const uid = li.dataset.uid;
    const name = li.querySelector(".u-name").textContent.toLowerCase();
    const preview = (userPreviewCache?.[uid]?.lastText||"").toLowerCase();
    const show = !q || name.includes(q) || preview.includes(q);
    li.style.display = show ? "" : "none";
  });
}

function filterFriendsList(){
  const q = (searchFriends.value||"").toLowerCase().trim();
  [...friendsList.children].forEach(li=>{
    if (li.tagName !== 'LI') return;
    const name = li.querySelector(".u-name").textContent.toLowerCase();
    const show = !q || name.includes(q);
    li.style.display = show ? "" : "none";
  });
}

function updateStatusIndicators(){
  [...chatList.children, ...friendsList.children].forEach(li=>{
    if (li.tagName !== 'LI') return;
    const uid = li.dataset.uid;
    const dot = li.querySelector(".dot");
    if(!dot) return;
    const userStatus = userStatusCache?.[uid];
    dot.className = "dot " + (userStatus?.state==="online" ? "online":"offline");
  });
  
  if(currentChat){
    const st = userStatusCache?.[currentChat];
    chatDot.className = "dot " + (st?.state==="online" ? "online":"offline");
    chatStatus.textContent = st?.state==="online" ? "online" : "offline";
  }
}

let msgListenerRef = null;
function openChat(uid, user){
  currentChat = uid;
  currentChatUser = user;
  chatName.textContent = user.name || "—";
  loadAvatar(chatAvatar, user.avatar, user.name, user.uid);
  
  const st = userStatusCache?.[uid];
  chatDot.className = "dot " + (st?.state==="online" ? "online":"offline");
  chatStatus.textContent = st?.state==="online" ? "online" : "offline";
  composer.style.display = "flex";
  messagesEl.innerHTML = "";
  
  updateBlockButtons();
  
  // Mobile navigation
  document.querySelector('.sidebar').classList.remove('active');
  document.querySelector('.chat').classList.add('active');
  
  if(msgListenerRef) msgListenerRef.off();
  const cid = chatId(me.uid, uid);
  msgListenerRef = db.ref("chats/"+cid);
  msgListenerRef.off();
  msgListenerRef.limitToLast(200).on("child_added", snap=>{
    const m = snap.val();
    appendMessage(m);
    if(m.from!==me.uid){ 
      createNotificationSound(800, 0.2);
      triggerAndroidNotification(); // Trigger Android notification
      // Mark as delivered
      updateMessageDeliveryStatus(snap.key);
    }
  });
  
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

function updateMessageDeliveryStatus(messageId) {
  if (currentChat) {
    db.ref(`messageStatus/${currentChat}/${messageId}`).set('delivered');
  }
}

function appendMessage(m){
  const row = document.createElement("div");
  row.className = "row "+(m.from===me.uid?"out":"in");
  row.dataset.messageId = m.id || 'msg_' + Date.now();
  
  const messageAvatar = document.createElement("img");
  messageAvatar.className = "message-avatar";
  messageAvatar.alt = "Avatar";
  
  if(m.from === me.uid) {
    loadAvatar(messageAvatar, meProfile?.avatar, meProfile?.name, me.uid);
    messageAvatar.onclick = () => openAvatarViewer(meProfile?.avatar, meProfile?.name);
  } else {
    const senderData = usersCache[m.from] || currentChatUser;
    loadAvatar(messageAvatar, senderData?.avatar, senderData?.name, m.from);
    messageAvatar.onclick = () => openAvatarViewer(senderData?.avatar, senderData?.name);
  }
  
  const messageWrapper = document.createElement("div");
  messageWrapper.className = "message-wrapper";
  
  const bubble = document.createElement("div");
  bubble.className = "bubble";
  
  if(m.type==="text"){
    bubble.innerHTML = linkify(m.text);
  }else if(m.type==="image"){
    const img = document.createElement("img");
    img.className = "msg-img";
    img.src = m.url;
    img.alt = "imagem";
    img.onclick = ()=> openViewer(m.url);
    bubble.appendChild(img);
    if(m.caption){
      const cap = document.createElement("div"); 
      cap.style.marginTop="6px"; 
      cap.innerHTML = linkify(m.caption);
      bubble.appendChild(cap);
    }
  }else if(m.type==="video"){
    const processedUrl = processVideoUrl(m.url);
    if(processedUrl){
      // Check if it's a direct video file
      if(m.url.match(/\.(mp4|webm|ogg)(\?.*)?$/i)){
        const video = document.createElement("video");
        video.className = "msg-video";
        video.src = processedUrl;
        video.controls = true;
        video.preload = "metadata";
        bubble.appendChild(video);
      } else {
        // Iframe for embedded videos
        const iframe = document.createElement("iframe");
        iframe.className = "msg-video";
        iframe.src = processedUrl;
        iframe.frameBorder = "0";
        iframe.allowFullscreen = true;
        iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
        bubble.appendChild(iframe);
      }
    } else {
      const errorDiv = document.createElement("div");
      errorDiv.className = "video-error";
      errorDiv.textContent = "❌ Vídeo não suportado";
      bubble.appendChild(errorDiv);
    }
  }
  
  const meta = document.createElement("div");
  meta.className = "meta";
  meta.textContent = formatTime(m.time);
  
  // Add message status for sent messages
  if (m.from === me.uid) {
    const statusSpan = document.createElement("span");
    statusSpan.className = "message-status sent";
    statusSpan.textContent = getStatusIcon('sent');
    meta.appendChild(statusSpan);
  }
  
  messageWrapper.appendChild(bubble);
  messageWrapper.appendChild(meta);
  
  row.appendChild(messageAvatar);
  row.appendChild(messageWrapper);
  
  messagesEl.appendChild(row);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

btnSend.onclick = sendText;
textInput.addEventListener("keydown", (e)=>{
  if(e.key==="Enter" && !e.shiftKey){ 
    e.preventDefault(); 
    sendText(); 
  }
});

function sendText(){
  const txt = (textInput.value||"").trim();
  if(!txt || !currentChat) return;
  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  sendMessage({type:"text", text: txt, id: messageId});
  textInput.value = "";
  createNotificationSound(600, 0.15);
}

btnImage.onclick = ()=> imageInput.click();
imageInput.onchange = async (e)=>{
  const file = e.target.files?.[0]; 
  if(!file || !currentChat) return;
  
  try {
    showToast('Enviando imagem...', 'info');
    const url = await uploadToImgBB(file);
    if(!url) return;
    const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    sendMessage({type:"image", url, id: messageId});
    imageInput.value = "";
    showToast('Imagem enviada! 📷', 'success');
  } catch(error) {
    console.error("Erro ao enviar imagem:", error);
    showToast("Erro ao enviar imagem", 'error');
  }
};

function sendMessage(payload){
  const to = currentChat;
  const cid = chatId(me.uid, to);
  const m = { from: me.uid, to, time: now(), ...payload };
  const updates = {};
  const newKey = db.ref("chats/"+cid).push().key;
  updates["/chats/"+cid+"/"+newKey] = m;

  // Set initial message status
  updates[`/messageStatus/${me.uid}/${payload.id}`] = 'sent';

  let previewText;
  if(payload.type==="text") previewText = payload.text;
  else if(payload.type==="image") previewText = "🖼️ Imagem";
  else if(payload.type==="video") previewText = "🎥 Vídeo";
  else previewText = "Mensagem";
  
  const mePrev = { other: to, lastText: previewText, lastTime: m.time };
  const toPrev = { other: me.uid, lastText: previewText, lastTime: m.time };
  updates["/userChats/"+me.uid+"/"+to] = mePrev;
  updates["/userChats/"+to+"/"+me.uid] = toPrev;

  db.ref().update(updates);
}

function openViewer(url){
  viewerImg.src = url;
  viewer.style.display = "grid";
}

viewer.onclick = (e)=>{
  if(e.target===viewer || e.target===viewerClose){ 
    viewer.style.display = "none"; 
    viewerImg.src=""; 
  } 
};

viewerClose.onclick = ()=>{ 
  viewer.style.display = "none"; 
  viewerImg.src=""; 
};

[profileModal, blockedModal, videoModal].forEach(modal => {
  modal.onclick = (e) => {
    if (e.target === modal) {
      modal.style.display = "none";
    }
  };
});

composer.style.display = "none";

// Mobile navigation
document.addEventListener('DOMContentLoaded', () => {
  const sidebar = document.querySelector('.sidebar');
  const chat = document.querySelector('.chat');

  if (!sidebar || !chat) return;

  sidebar.classList.add('active');
  chat.classList.remove('active');
});

// Swipe gesture for mobile
let touchStartX = 0;
let touchEndX = 0;

document.querySelector('.chat').addEventListener('touchstart', (e) => {
  touchStartX = e.changedTouches[0].screenX;
});

document.querySelector('.chat').addEventListener('touchend', (e) => {
  touchEndX = e.changedTouches[0].screenX;
  handleSwipe();
});

function handleSwipe() {
  const swipeDistance = touchEndX - touchStartX;
  if (swipeDistance > 80) {
    goToHome();
  }
}
</script>
</body>
</html>