<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat Movicel</title>
 
<style>
:root{
  --bg:#f2f5f7; --card:#fff; --line:#e6e9ef; --text:#1f2937; --muted:#6b7280;
  --brand:#1a73e8; --in:#ffffff; --out:#1a73e8; --out-text:#ffffff; --radius:14px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg:#181818; --card:#2a2a2a; --line:#404040; --text:#ffffff; --muted:#a0a0a0;
    --brand:#4285f4; --in:#3a3a3a; --out:#4285f4; --out-text:#ffffff;
  }
}

*{box-sizing:border-box}
body{width:100%; margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;background:var(--bg);color:var(--text);overflow:hidden}
#app{display:grid;grid-template-columns:100% 1fr;width:100%;height:100vh;max-height:100vh}

/* Splash Screen */
.splash-screen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 1;
  transition: opacity 0.8s ease;
}

.splash-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

.splash-logo {
  width: 120px;
  height: 120px;
  background: white;
  border-radius: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 48px;
  margin-bottom: 20px;
  animation: pulse 2s infinite;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.splash-title {
  color: white;
  font-size: 28px;
  font-weight: 700;
  margin-bottom: 10px;
  text-align: center;
}

.splash-subtitle {
  color: rgba(255,255,255,0.8);
  font-size: 16px;
  text-align: center;
  margin-bottom: 30px;
}

.splash-loader {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255,255,255,0.3);
  border-top: 3px solid white;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.splash-status {
  color: rgba(255,255,255,0.9);
  font-size: 14px;
  margin-top: 20px;
  text-align: center;
  min-height: 20px;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* PIN Security */
.pin-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.9);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 90000;
  backdrop-filter: blur(10px);
}

.pin-modal {
  background: var(--card);
  border-radius: 20px;
  padding: 30px;
  max-width: 350px;
  width: calc(100% - 40px);
  text-align: center;
  box-shadow: 0 20px 40px rgba(0,0,0,0.3);
}

.pin-title {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 10px;
  color: var(--text);
}

.pin-subtitle {
  color: var(--muted);
  margin-bottom: 30px;
  font-size: 14px;
}

.pin-input {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-bottom: 30px;
}

.pin-digit {
  width: 50px;
  height: 50px;
  border: 2px solid var(--line);
  border-radius: 12px;
  text-align: center;
  font-size: 24px;
  font-weight: 700;
  background: var(--card);
  color: var(--text);
  transition: all 0.2s ease;
}

.pin-digit:focus {
  border-color: var(--brand);
  outline: none;
  transform: scale(1.05);
}

.pin-digit.filled {
  background: var(--brand);
  color: white;
  border-color: var(--brand);
}

.pin-buttons {
  display: flex;
  gap: 12px;
  justify-content: center;
}

.pin-btn {
  padding: 12px 24px;
  border: none;
  border-radius: 10px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pin-btn.primary {
  background: var(--brand);
  color: white;
}

.pin-btn.secondary {
  background: var(--line);
  color: var(--text);
}

.pin-btn:hover {
  transform: translateY(-1px);
  opacity: 0.9;
}

.pin-error {
  color: #ef4444;
  font-size: 12px;
  margin-top: 10px;
  display: none;
}

.sidebar, .chat {
  display: none;
}
.sidebar.active, .chat.active {
  display: flex;
}

.sidebar{background:var(--card);border-right:1px solid var(--line);flex-direction:column}
.topbar{padding:12px 14px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:10px }
.me{display:flex;align-items:center;gap:10px;flex:1}

.me .avatar{
  width:36px;
  height:36px;
  border-radius:50%;
  object-fit:cover;
  background:linear-gradient(135deg, #667eea, #764ba2);
  border: 2px solid var(--line);
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 600;
  font-size: 12px;
  cursor: pointer;
}

.me .avatar.loaded {
  background: none;
}

.me .avatar:hover {
  transform: scale(1.05);
  border-color: var(--brand);
}

.me .info{display:flex;flex-direction:column}
.me .info .name{font-weight:600;font-size:14px}
.me .info .email{font-size:12px;color:var(--muted)}

.actions{display:flex;gap:8px}
.actions button{color:#fff;border:0;border-radius:0px;padding:0px 0px;cursor:pointer;transition:all 0.2s ease}
.actions button:hover{opacity:0.9;transform:translateY(-1px)}

/* Tabs Navigation */
.tabs-nav {
  display: flex;
  border-bottom: 1px solid var(--line);
  background: var(--card);
}

.tab-btn {
  flex: 1;
  padding: 12px 8px;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s ease;
  position: relative;
}

.tab-btn.active {
  color: var(--brand);
  border-bottom-color: var(--brand);
}

.tab-btn:hover {
  background: var(--line);
}

.tab-content {
  display: none;
  flex-direction: column;
  flex: 1;
  overflow: hidden;
}

.tab-content.active {
  display: flex;
}

.search{padding:8px 12px;border-bottom:1px solid var(--line)}
.search input{width:100%;padding:10px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}

.user-list{list-style:none;margin:0;padding:0;overflow:auto;flex:1}
.user-item{display:grid;grid-template-columns:48px 1fr auto;align-items:center;gap:10px;padding:10px 12px;cursor:pointer;border-bottom:1px solid var(--line);transition:background-color 0.2s ease}
.user-item:hover{background:rgba(26,115,232,0.05)}

.avatar{
  width:44px;
  height:44px;
  border-radius:50%;
  object-fit:cover;
  background:linear-gradient(135deg, #667eea, #764ba2);
  border: 2px solid var(--line);
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 600;
  font-size: 14px;
  flex-shrink: 0;
  cursor: pointer;
}

.avatar.loaded {
  background: none;
}

.avatar:hover {
  transform: scale(1.05);
  border-color: var(--brand);
}

.u-main{display:flex;flex-direction:column;min-width:0}
.u-name{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:14px}
.u-preview{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-top:2px}
.u-right{text-align:right;display:flex;flex-direction:column;align-items:flex-end;gap:4px}
.u-time{font-size:11px;color:var(--muted)}
.dot{width:10px;height:10px;border-radius:50%;transition:all 0.2s ease}
.dot.online{background:#10b981;box-shadow:0 0 6px rgba(16,185,129,0.4)}
.dot.offline{background:#9ca3af}

/* Friend Action Button */
.friend-action {
  background: var(--brand);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.friend-action:hover {
  transform: translateY(-1px);
  opacity: 0.9;
}

.friend-action.remove {
  background: #ef4444;
}

.friend-action.pending {
  background: #f59e0b;
}

/* Friend Request Styles */
.friend-request-badge {
  background: #ef4444;
  color: white;
  border-radius: 10px;
  padding: 2px 6px;
  font-size: 11px;
  margin-left: 4px;
  min-width: 16px;
  text-align: center;
}

.request-actions {
  display: flex;
  gap: 4px;
  flex-direction: column;
}

.request-btn {
  padding: 4px 8px;
  border: none;
  border-radius: 4px;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

.request-btn.accept {
  background: #10b981;
  color: white;
}

.request-btn.decline {
  background: #ef4444;
  color: white;
}

.request-btn:hover {
  transform: translateY(-1px);
  opacity: 0.9;
}

.chat{flex-direction:column; width:100%; height:100vh;max-height:100vh}
.chat-header{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid var(--line);background:var(--card)}
.chat-header .avatar{width:40px;height:40px}
.title{display:flex;flex-direction:column;flex:1}
.title .name{font-weight:700;font-size:16px}
.title .status{font-size:12px;color:var(--muted);display:flex;align-items:center;gap:6px;margin-top:2px}

/* Chat Back Button */
.chat-back {
  background: none;
  border: none;
  color: var(--text);
  font-size: 18px;
  padding: 8px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.chat-back:hover {
  background: var(--line);
  transform: scale(1.05);
}

/* Chat Actions */
.chat-actions{display:flex;gap:8px;margin-left:auto}
.chat-btn{background:none;border:1px solid var(--line);color:var(--text);padding:6px 12px;border-radius:8px;cursor:pointer;font-size:12px;transition:all 0.2s ease}
.chat-btn:hover{background:var(--line)}
.chat-btn.block{border-color:#ef4444;color:#ef4444}
.chat-btn.block:hover{background:#ef4444;color:white}
.chat-btn.unblock{border-color:#10b981;color:#10b981}
.chat-btn.unblock:hover{background:#10b981;color:white}

.messages{flex:1;overflow:auto;padding:14px;background:var(--bg);display:flex;flex-direction:column;gap:10px}

/* Mensagens com Avatares e Status */
.row{display:flex;align-items:flex-start;gap:8px;margin-bottom:12px}
.row.in{justify-content:flex-start}
.row.out{justify-content:flex-end;flex-direction:row-reverse}

.message-avatar{
  width:32px;
  height:32px;
  border-radius:50%;
  object-fit:cover;
  background:linear-gradient(135deg, #667eea, #764ba2);
  border: 2px solid var(--line);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 600;
  font-size: 10px;
  flex-shrink: 0;
  margin-top: 4px;
  cursor: pointer;
}

.message-avatar.loaded {
  background: none;
}

.message-wrapper{
  display:flex;
  flex-direction:column;
  max-width:70%;
  position: relative;
}

.message-actions {
  position: absolute;
  top: -8px;
  right: -8px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.row.out .message-actions {
  left: -8px;
  right: auto;
}

.row:hover .message-actions {
  opacity: 1;
}

.delete-btn {
  background: #ef4444;
  color: white;
  border: none;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.delete-btn:hover {
  background: #dc2626;
  transform: scale(1.1);
}

.bubble{
  padding:10px 12px;
  border-radius:16px;
  line-height:1.35;
  word-wrap:break-word;
  overflow-wrap:anywhere;
  box-shadow:0 1px 2px rgba(0,0,0,0.1);
}

.in .bubble{
  background:var(--in);
  border-bottom-left-radius:4px;
}

.out .bubble{
  background:var(--brand);
  color:var(--out-text);
  border-bottom-right-radius:4px;
}

.msg-img{border-radius:10px;max-width:100%;cursor:pointer;display:block}
.meta{font-size:11px;color:var(--muted);margin-top:4px;padding:0 4px;display:flex;align-items:center;gap:6px}

/* Message Status Icons */
.message-status {
  font-size: 10px;
  color: var(--muted);
  transition: all 0.2s ease;
}

.message-status.sent {
  color: #6b7280;
}

.message-status.delivered {
  color: #3b82f6;
}

.message-status.read {
  color: #10b981;
}

.composer{display:none;gap:8px;padding:10px;border-top:1px solid var(--line);background:var(--card);position:relative}
.composer button{background:var(--brand);color:#fff;border:0;border-radius:10px;padding:0 0px;cursor:pointer;height:40px;transition:all 0.2s ease}
.composer button:hover{opacity:0.9;transform:translateY(-1px)}

#textInput{flex:1;min-height:40px;max-height:120px;resize:none;padding:10px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}
#btnImage{width:40px;display:grid;place-items:center}
#btnEmoji{width:40px;display:grid;place-items:center}

/* Attachment Menu */
.attachment-menu {
  position: absolute;
  bottom: 100%;
  left: 0;
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  display: none;
  z-index: 1000;
  padding: 8px;
  min-width: 180px;
}

.attachment-menu.show {
  display: block;
}

.attachment-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  border: none;
  background: none;
  width: 100%;
  text-align: left;
  border-radius: 8px;
  cursor: pointer;
  color: var(--text);
  font-size: 14px;
  transition: all 0.2s ease;
}

.attachment-option:hover {
  background: var(--card);
}

.attachment-option .icon {
  font-size: 20px;
  width: 24px;
  text-align: center;
  color: #6b7280;
}

/* Video Link Modal */
.video-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1500;
  backdrop-filter: blur(4px);
}

.video-modal-content {
  background: var(--card);
  border-radius: 16px;
  padding: 24px;
  max-width: 500px;
  width: calc(100% - 40px);
  box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3);
}

.video-modal h3 {
  margin: 0 0 16px 0;
  color: var(--text);
  font-size: 18px;
  font-weight: 600;
}

.video-modal input {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--line);
  border-radius: 10px;
  background: var(--card);
  color: var(--text);
  font-size: 16px;
  margin-bottom: 16px;
}

.video-modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.video-modal-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.video-modal-btn.cancel {
  background: var(--line);
  color: var(--text);
}

.video-modal-btn.send {
  background: var(--brand);
  color: white;
}

.video-modal-btn:hover {
  transform: translateY(-1px);
  opacity: 0.9;
}

/* Emoji Picker */
.emoji-picker {
  position: absolute;
  bottom: 100%;
  left: 50px;
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  display: none;
  z-index: 1000;
  width: 320px;
  max-height: 300px;
  overflow: hidden;
}

.emoji-picker.show {
  display: block;
}

.emoji-header {
  padding: 12px 16px;
  border-bottom: 1px solid var(--line);
  font-weight: 600;
  color: var(--text);
  font-size: 14px;
}

.emoji-categories {
  display: flex;
  padding: 8px;
  border-bottom: 1px solid var(--line);
  gap: 4px;
}

.emoji-category {
  padding: 8px 12px;
  border: none;
  background: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s ease;
}

.emoji-category:hover,
.emoji-category.active {
  background: var(--line);
}

.emoji-grid {
  padding: 12px;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 4px;
  max-height: 200px;
  overflow-y: auto;
}

.emoji-item {
  padding: 8px;
  border: none;
  background: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 20px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.emoji-item:hover {
  background: var(--line);
  transform: scale(1.2);
}

/* Large Emoji Messages */
.emoji-large {
  font-size: 64px !important;
  line-height: 1.2;
  padding: 8px !important;
}

.emoji-medium {
  font-size: 48px !important;
  line-height: 1.2;
  padding: 6px !important;
}

.emoji-small {
  font-size: 32px !important;
  line-height: 1.2;
  padding: 4px !important;
}

.viewer{position:fixed;inset:0;background:rgba(0,0,0,.9);display:none;place-items:center;z-index:1000}
.viewer img{max-width:95vw;max-height:90vh;border-radius:12px}
.viewer-close{position:fixed;top:16px;right:16px;background:#111;color:#fff;border:0;border-radius:10px;padding:8px 12px;cursor:pointer}

/* Avatar Viewer */
.avatar-viewer{position:fixed;inset:0;background:rgba(0,0,0,.9);display:none;align-items:center;justify-content:center;z-index:1050;backdrop-filter:blur(4px)}
.avatar-viewer img{max-width:80vw;max-height:80vh;border-radius:20px;box-shadow:0 20px 40px rgba(0,0,0,0.5)}
.avatar-viewer-close{position:fixed;top:20px;right:20px;background:rgba(255,255,255,0.2);color:#fff;border:0;border-radius:50%;width:50px;height:50px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:20px;backdrop-filter:blur(10px)}
.avatar-viewer-name{position:fixed;bottom:30px;left:50%;transform:translateX(-50%);color:white;font-size:18px;font-weight:600;text-shadow:0 2px 10px rgba(0,0,0,0.5)}

.auth{position:fixed;inset:0;background:rgba(15,23,42,0.8);display:none;align-items:center;justify-content:center;padding:20px;z-index:1100;backdrop-filter:blur(4px)}
.auth-card{background:var(--card);border-radius:16px;max-width:380px;width:100%;padding:20px;display:flex;flex-direction:column;gap:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,0.1)}
.auth-card h2{margin:0;color:var(--text)}
.auth-card input{padding:10px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}
.row-line{display:flex;gap:8px}
.row-line>*{flex:1}

.profile{position:fixed;inset:0;background:rgba(15,23,42,0.8);display:none;align-items:center;justify-content:center;padding:20px;z-index:1200;backdrop-filter:blur(4px)}
.profile-card{background:var(--card);border-radius:16px;max-width:420px;width:100%;padding:20px;display:flex;flex-direction:column;gap:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,0.1)}
.profile-card h3{margin:0;color:var(--text)}
.profile-card label{color:var(--text);font-weight:500}
.profile-card input{padding:10px;border:1px solid var(--line);border-radius:10px;background:var(--card);color:var(--text);font-size:16px}
.help{font-size:12px;color:var(--muted)}
.link{color:#DEBCCE;text-decoration:none}
.hidden{display:none}

/* PIN Settings */
.pin-settings {
  margin: 15px 0;
  padding: 15px;
  border: 1px solid var(--line);
  border-radius: 10px;
  background: var(--bg);
}

.pin-toggle {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.pin-toggle input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: var(--brand);
}

/* Blocked Users Modal */
.blocked-modal{position:fixed;inset:0;background:rgba(15,23,42,0.8);display:none;align-items:center;justify-content:center;padding:20px;z-index:1300;backdrop-filter:blur(4px)}
.blocked-card{background:var(--card);border-radius:16px;max-width:500px;width:100%;padding:20px;display:flex;flex-direction:column;gap:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,0.1);max-height:70vh;overflow:hidden}
.blocked-card h3{margin:0;color:var(--text)}
.blocked-list{flex:1;overflow:auto;margin:10px 0}
.blocked-item{display:flex;align-items:center;gap:12px;padding:12px;border:1px solid var(--line);border-radius:8px;margin-bottom:8px}
.blocked-item .avatar{width:40px;height:40px}
.blocked-item .info{flex:1}
.blocked-item .name{font-weight:600;margin-bottom:4px}
.blocked-item .email{font-size:12px;color:var(--muted)}
.unblock-btn{background:#10b981;color:white;border:0;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:12px}
.unblock-btn:hover{background:#059669}

.loading-placeholder {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

.back-button {
  display: inline-flex;
  background-color: transparent;
  align-items: center;
  gap: 8px;
  padding: 10px 6px;
  color: var(--text);
  font-size: 14px;
  font-weight: 600;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.back-button:hover {
  transform: scale(1.05);
  background: var(--line);
}

.toast-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-width: 400px;
}

.toast {
  padding: 12px 16px;
  border-radius: 8px;
  color: white;
  font-weight: 500;
  font-size: 14px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  transform: translateX(100%);
  animation: slideIn 0.3s ease forwards;
}

.toast.success { background: #10b981; }
.toast.error { background: #ef4444; }
.toast.info { background: #3b82f6; }

@keyframes slideIn { to { transform: translateX(0); } }
@keyframes slideOut { to { transform: translateX(100%); } }

/* Responsivo */
@media (max-width: 768px) {
  .message-wrapper { max-width: 85%; }
  .row { gap: 6px; }
  .message-avatar { width: 28px; height: 28px; font-size: 9px; }
  .chat-actions { gap: 4px; }
  .chat-btn { padding: 4px 8px; font-size: 11px; }
  .pin-input { gap: 10px; }
  .pin-digit { width: 45px; height: 45px; font-size: 20px; }
  .emoji-picker { width: 280px; }
  .emoji-grid { grid-template-columns: repeat(6, 1fr); }
}
  .icon {
  background-color: #fff;   /* fundo branco */
  display: inline-flex;     /* centraliza o SVG */
  align-items: center;
  justify-content: center;
  border-radius: 4px;       /* opcional: cantos levemente arredondados */
  padding: 4px;             /* espaço interno */
}

.icon svg {
  width: 34px;              /* tamanho do ícone */
  height: 34px;
                /* preenchimento preto */
}
</style>
</head>
<body>
<script>
  window.onload = function() {
    setTimeout(function() {
      var splash = document.getElementById("splashScreen");
      if (splash) {
        splash.style.display = "none";
      }
    }, 30000);
  };
</script>
 <script>
window.addEventListener("load", function() {
  const splash = document.getElementById("splashScreen");
  const pin = document.getElementById("pinOverlay");
  const pinCheckbox = document.getElementById("pinEnabled");

  // Mostra o splash primeiro
  splash.style.display = "flex";

  // Depois de 3s, esconde o splash
  setTimeout(() => {
    splash.style.display = "none";

    // Só mostra o PIN se o checkbox estiver marcado
    if (pinCheckbox && pinCheckbox.checked) {
      pin.style.display = "flex";
    }
  }, 30000); // tempo do splash
});
</script>
<div  class="splash-screen" id="splashScreen">
  <div class="splash-logo">💬</div>
  <div class="splash-title">Bate-papo</div>
  <div class="splash-subtitle">  Carregando suas mensagens </div>
  <div class="splash-loader"></div>
  <div class="splash-status" id="splashStatus">Iniciando aplicação...</div>
</div>

<!-- PIN Security -->
<div class="pin-overlay" id="pinOverlay">
  <div class="pin-modal">
    <div class="pin-title"> Segurança</div>
    <div class="pin-subtitle" id="pinSubtitle">Digite seu PIN de 4 dígitos</div>
    <div class="pin-input">
      <input type="password" class="pin-digit" maxlength="1" data-index="0">
      <input type="password" class="pin-digit" maxlength="1" data-index="1">
      <input type="password" class="pin-digit" maxlength="1" data-index="2">
      <input type="password" class="pin-digit" maxlength="1" data-index="3">
    </div>
    <div class="pin-buttons">
      <button class="pin-btn secondary" id="pinCancel">Cancelar</button>
      <button class="pin-btn primary" id="pinConfirm">Confirmar</button>
    </div>
    <div class="pin-error" id="pinError">PIN incorreto. Tente novamente.</div>
  </div>
</div>

<div class="toast-container" id="toastContainer"></div>

<!-- Botão oculto para notificações Android -->
<button id="btnNotif" onclick="Android.showNotification()" style="display:none;"></button>

<div id="app">
  <aside class="sidebar">
    <div class="topbar">  
      <span style="font-weight:bold;
             font-size:18px;
             color:#111;
             margin-right:auto;
             display:inline-block;">
  Mensagens
</span>
      <div style="display:none;"  class="me">
        <img src="" id="meAvatar" class="avatar" alt="Meu Avatar" onclick="openAvatarViewer(this.src, document.getElementById('meName').textContent)">
        <div class="info">
          <div id="meName" class="name">Carregando...</div>
          <div id="meEmail" class="email">--</div>
        </div>
      </div>
      <div class="actions">
        <button id="btnEdit" title="Editar Perfil"><!-- Chat seguro com fundo branco (48x48) -->
<span class="icon" aria-hidden="true">
 <!-- Cadeado com fundo branco e ícone preto -->
<svg width="20" height="20" viewBox="0 0 24 24"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Cadeado">
  <title>Cadeado</title>
  <!-- Fundo branco -->
  <rect width="24" height="24" fill="white"/>
  <!-- Corpo do cadeado -->
  <rect x="5.5" y="10" width="13" height="8.5" rx="1.8"
        stroke="black" stroke-width="1.8" fill="none"/>
  <!-- Arco do cadeado -->
  <path d="M8.5 10V8a3.5 3.5 0 0 1 7 0v2"
        stroke="black" stroke-width="1.8" stroke-linecap="round" fill="none"/>
  <!-- Miolo -->
  <circle cx="12" cy="14.5" r="0.9" fill="black"/>
</svg>
</span></button>
        <button id="btnBlocked" title="Usuários Bloqueados"><!-- Ícone alternativo de perfil bloqueado com fundo branco -->
<span class="icon" aria-hidden="true">
  <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"
       role="img" aria-label="Perfil bloqueado">
    <title>Perfil bloqueado</title>
    <!-- Fundo branco -->
    <rect width="50" height="50" fill="#FFFFFF" rx="8"/>

    <!-- Silhueta do perfil -->
    <circle cx="18" cy="18" r="6" stroke="#000000" stroke-width="2" fill="none"/>
    <path d="M8 36c0-5.5 4.5-10 10-10s10 4.5 10 10" 
          stroke="#000000" stroke-width="2" fill="none" stroke-linecap="round"/>

    <!-- Cadeado ao lado -->
    <rect x="28" y="22" width="10" height="7" rx="1.5"
          stroke="#000000" stroke-width="2" fill="none"/>
    <path d="M31 22v-2a3 3 0 1 1 6 0v2" 
          stroke="#000000" stroke-width="2" fill="none" stroke-linecap="round"/>
    <circle cx="33" cy="25.5" r="1" fill="#000000"/>
  </svg>
</span></button>
        <button style="display:none;" id="btnLogout" title="Sair">🚪</button>
      </div>
    </div>

    <!-- Tabs Navigation -->
    <div class="tabs-nav">
      <button class="tab-btn active" data-tab="my-chats">Meus Chats</button>
      <button class="tab-btn" data-tab="all-friends" id="friendsTab">
        Adicionar Amigos
        <span class="friend-request-badge" id="friendRequestBadge" style="display:none;">0</span>
      </button>
    </div>

    <!-- Tab: Meus Chats -->
    <div class="tab-content active" id="my-chats">
      <div class="search">
        <input id="searchChats" placeholder="Pesquisar conversas..." />
      </div>
      <ul id="chatList" class="user-list"></ul>
    </div>

    <!-- Tab: Todos Amigos -->
    <div class="tab-content" id="all-friends">
      <div class="search">
        <input id="searchFriends" placeholder="Pesquisar amigos..." />
      </div>
      <ul id="friendsList" class="user-list"></ul>
    </div>
  </aside>

  <section class="chat">
    <header class="chat-header">
      <button class="chat-back" id="chatBack" title="Voltar">←</button>
      <img id="chatAvatar" class="avatar" alt="Avatar do contato" onclick="openAvatarViewer(this.src, document.getElementById('chatName').textContent)">
      <div class="title">
        <div id="chatName" class="name">Selecione um usuário</div>
        <div class="status">
          <span id="chatDot" class="dot offline"></span>
          <span id="chatStatus">--</span>
        </div>
      </div>
      <div class="chat-actions">
        <button id="blockBtn" class="chat-btn block" style="display:none">🚫 Bloquear</button>
        <button id="unblockBtn" class="chat-btn unblock" style="display:none">✅ Desbloquear</button>
      </div>
    </header>
    <div id="messages" class="messages"></div>
    <div id="composer" class="composer">
      <button id="btnAttachment" title="Anexos" style="background: var(--card); color: black; padding: 4px 4px;"><svg xmlns="http://www.w3.org/2000/svg" 
     fill="none" 
     viewBox="0 0 24 24" 
     stroke-width="1.5" 
     stroke="currentColor" 
     style="width:32px;height:32px;display:block;margin-right:auto;">
  <path stroke-linecap="round" stroke-linejoin="round" 
        d="M12 9v6m3-3H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
</svg></button>
      <input id="imageInput" type="file" accept="image/*" class="hidden" />
      
      <textarea id="textInput" rows="1" placeholder="Digite uma mensagem"></textarea>
      <button style="
  background-color: white;
  color: black;
  border: none;" id="btnSend"><!-- Ícone de enviar mensagem com fundo branco e ícone preto -->
<!-- Ícone de enviar mensagem (avião de papel) com fundo branco e ícone preto -->
<svg width="34" height="34" viewBox="0 0 24 24"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Enviar mensagem">
  <title>Enviar mensagem</title>
  <!-- Fundo branco -->
  <rect width="24" height="24" fill="white"/>
  <!-- Avião de papel -->
  <path d="M3 20L21 12L3 4V10L15 12L3 14V20Z"
        fill="black"/>
</svg></button>

      <!-- Attachment Menu -->
      <div class="attachment-menu" id="attachmentMenu">
        <button class="attachment-option" id="optionImage" style="background: var(--card); color: black;">
          <span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm10.5-11.25h.008v.008h-.008V8.25Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z" />
</svg>
</span>
          <span>Imagem</span>
        </button>     
        <button class="attachment-option" id="optionVideoLink" style="background: var(--card); color: black;">
          <span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.91 11.672a.375.375 0 0 1 0 .656l-5.603 3.113a.375.375 0 0 1-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112Z" />
</svg>
</span>
          <span>Vídeo (link)</span>
        </button>
        <button class="attachment-option" id="optionEmoji" style="background: var(--card); color: black;">
          <span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.182 15.182a4.5 4.5 0 0 1-6.364 0M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0ZM9.75 9.75c0 .414-.168.75-.375.75S9 10.164 9 9.75 9.168 9 9.375 9s.375.336.375.75Zm-.375 0h.008v.015h-.008V9.75Zm5.625 0c0 .414-.168.75-.375.75s-.375-.336-.375-.75.168-.75.375-.75.375.336.375.75Zm-.375 0h.008v.015h-.008V9.75Z" />
</svg>
</span>
          <span>Emoji</span>
        </button>
      </div>

      <!-- Emoji Picker -->
      <div class="emoji-picker" id="emojiPicker">
        <div class="emoji-header">Escolha um emoji</div>
        <div class="emoji-categories">
          <button class="emoji-category active" data-category="smileys">😊</button>
          <button class="emoji-category" data-category="people">👨</button>
          <button class="emoji-category" data-category="animals">🐶</button>
          <button class="emoji-category" data-category="food">🍎</button>
          <button class="emoji-category" data-category="activities">⚽</button>
          <button class="emoji-category" data-category="travel">🚗</button>
          <button class="emoji-category" data-category="objects">💡</button>
          <button class="emoji-category" data-category="symbols">❤️</button>
        </div>
        <div class="emoji-grid" id="emojiGrid"></div>
      </div>
    </div>
  </section>
</div>

<!-- Video Link Modal -->
<div class="video-modal" id="videoModal">
  <div class="video-modal-content">
    <h3>Adicionar vídeo por link</h3>
    <input 
      type="url" 
      id="videoLinkInput" 
      placeholder="Cole aqui o link do YouTube ou vídeo direto (mp4, webm, etc.)" 
    />
    <div class="video-modal-buttons">
      <button class="video-modal-btn cancel" id="videoModalCancel">Cancelar</button>
      <button class="video-modal-btn send" id="videoModalSend">Enviar</button>
    </div>
  </div>
</div>

<div id="viewer" class="viewer">
  <img id="viewerImg" alt="">
  <button class="viewer-close" id="viewerClose">Fechar</button>
</div>

<!-- Avatar Viewer -->
<div id="avatarViewer" class="avatar-viewer">
  <img id="avatarViewerImg" alt="">
  <button class="avatar-viewer-close" id="avatarViewerClose">×</button>
  <div class="avatar-viewer-name" id="avatarViewerName"></div>
</div>

<div id="auth" class="auth">
  <div style="display:none;"  class="auth-card">
    <h2>Entrar</h2>
    <p class="help">Use a sessão existente ou entre agora.</p>
    <div class="row-line">
      <button id="btnGoogle" style="background:#ea4335">Google</button>
      <button id="btnAnon">Anônimo</button>
    </div>
    <p class="help">Após entrar, você poderá definir nome e foto.</p>
  </div>
</div>

<div id="profile" class="profile">
  <div class="profile-card">    
      <input style="display:none;" id="pName" placeholder="Seu nome" />
    <div class="row-line">
      <div style="display:none">
        <label>Foto (URL)</label>
        <input style="display:none;" id="pAvatar" placeholder="https://..." />
      </div>
      <div>
        <label style="display:none;">Adicione sua foto</label>
        <input style="display:none;" id="pFile" type="file" accept="image/*" />
      </div>
    </div>
    <div style="display:none;" class="help">A foto pode ser enviada e hospedada automaticamente.</div>
    
    <!-- PIN Settings -->
    <div class="pin-settings">
      <div class="pin-toggle">
        <input type="checkbox" id="pinEnabled">
        <label for="pinEnabled">Ativar PIN de segurança</label>
      </div>
      <div class="help">Protege o acesso ao suas conversas com um PIN de 4 dígitos</div>
      <div id="pinSetup" style="display:none;">
        <label>Novo PIN (4 dígitos)</label>
        <input id="newPin" type="password" maxlength="4" placeholder="••••" />
      </div>
    </div>
    
    <div class="row-line">
      <button id="pSave" style="
  background-color: #10b981; /* verde */
  color: white;
  border: none;
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
">
  Salvar
</button>

<button id="pClose" style="
  background-color: #6b7280; /* cinza */
  color: white;
  border: none;
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
">
  Fechar
</button>  </div>
  </div>
</div>

<div id="blockedModal" class="blocked-modal">
  <div class="blocked-card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">
      <h3>Usuários Bloqueados</h3>
      <button id="closeBlockedModal" style="background:none;border:none;font-size:20px;cursor:pointer;color:var(--text)">×</button>
    </div>
    <div class="blocked-list" id="blockedList">
    </div>
    <p class="help">Usuários bloqueados não aparecem na sua lista de contatos e não podem enviar mensagens para você.</p>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script>
const firebaseConfig = {
  apiKey: "AIzaSyCE_vGty5XsV1YqdCi49Ck2xJDSFq284wc",
  authDomain: "cliente-movicel.firebaseapp.com",
  databaseURL: "https://cliente-movicel-default-rtdb.firebaseio.com",
  projectId: "cliente-movicel",
  storageBucket: "cliente-movicel.firebasestorage.app",
  messagingSenderId: "215414688375",
  appId: "1:215414688375:web:2c7d20a0c03c4c0fcfd472",
  measurementId: "G-7F1RGP9GHV"
};

const IMGBB_KEY = "e073e02267a1f0259cd69c562e780659";

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

let me = null;
let meProfile = null;
let currentChat = null;
let currentChatUser = null;
let userStatusCache = {};
let userPreviewCache = {};
let usersCache = {};
let blockedUsers = {};
let messageStatusCache = {};
let friendsInChat = {}; // Lista de amigos que estão no chat
let friendRequests = {}; // Pedidos de amizade enviados
let receivedRequests = {}; // Pedidos de amizade recebidos
let currentTab = 'my-chats';

// Emoji categories data
const emojiCategories = {
  smileys: ['😀','😃','😄','😁','😆','😅','🤣','😂','🙂','🙃','😉','😊','😇','🥰','😍','🤩','😘','😗','☺️','😚','😙','🥲','😋','😛','😜','🤪','😝','🤑','🤗','🤭','🤫','🤔','🤐','🤨','😐','😑','😶','😏','😒','🙄','😬','🤥','😔','😪','🤤','😴','😷','🤒','🤕','🤢','🤮','🤧','🥵','🥶','🥴','😵','🤯','🤠','🥳','🥸','😎','🤓','🧐'],
  people: ['👶','🧒','👦','👧','🧑','👱','👨','🧔','👨‍🦰','👨‍🦱','👨‍🦳','👨‍🦲','👩','👩‍🦰','🧑‍🦰','👩‍🦱','🧑‍🦱','👩‍🦳','🧑‍🦳','👩‍🦲','🧑‍🦲','👱‍♀️','👱‍♂️','🧓','👴','👵','🙍','🙍‍♂️','🙍‍♀️','🙎','🙎‍♂️','🙎‍♀️','🙅','🙅‍♂️','🙅‍♀️','🙆','🙆‍♂️','🙆‍♀️','💁','💁‍♂️','💁‍♀️','🙋','🙋‍♂️','🙋‍♀️','🧏','🧏‍♂️','🧏‍♀️','🙇','🙇‍♂️','🙇‍♀️','🤦','🤦‍♂️','🤦‍♀️'],
  animals: ['🐶','🐱','🐭','🐹','🐰','🦊','🐻','🐼','🐻‍❄️','🐨','🐯','🦁','🐮','🐷','🐽','🐸','🐵','🙈','🙉','🙊','🐒','🐔','🐧','🐦','🐤','🐣','🐥','🦆','🦅','🦉','🦇','🐺','🐗','🐴','🦄','🐝','🐛','🦋','🐌','🐞','🐜','🦟','🦗','🕷️','🕸️','🦂','🐢','🐍','🦎','🦖','🦕','🐙','🦑','🦐','🦞','🦀','🐡','🐠','🐟','🐬','🐳','🐋','🦈','🐊','🐅','🐆','🦓','🦍','🦧','🐘','🦛','🦏','🐪','🐫','🦒','🦘','🐃','🐂','🐄','🐎','🐖','🐏','🐑','🦙','🐐','🦌','🐕','🐩','🦮','🐕‍🦺','🐈','🐈‍⬛','🐓','🦃','🦚','🦜','🦢','🦩','🕊️','🐇','🦝','🦨','🦡','🦦','🦥','🐁','🐀','🐿️','🦔'],
  food: ['🍎','🍐','🍊','🍋','🍌','🍉','🍇','🍓','🫐','🍈','🍒','🍑','🥭','🍍','🥥','🥝','🍅','🍆','🥑','🥦','🥬','🥒','🌶️','🫑','🌽','🥕','🫒','🧄','🧅','🥔','🍠','🥐','🥯','🍞','🥖','🥨','🧀','🥚','🍳','🧈','🥞','🧇','🥓','🥩','🍗','🍖','🦴','🌭','🍔','🍟','🍕','🫓','🥪','🥙','🧆','🌮','🌯','🫔','🥗','🥘','🫕','🥫','🍝','🍜','🍲','🍛','🍣','🍱','🥟','🦪','🍤','🍙','🍚','🍘','🍥','🥠','🥮','🍢','🍡','🍧','🍨','🍦','🥧','🧁','🍰','🎂','🍮','🍭','🍬','🍫','🍿','🍩','🍪','🌰','🥜','🍯'],
  activities: ['⚽','🏀','🏈','⚾','🥎','🎾','🏐','🏉','🥏','🎱','🪀','🏓','🏸','🏒','🏑','🥍','🏏','🪃','🥅','⛳','🪁','🏹','🎣','🤿','🥊','🥋','🎽','🛹','🛷','⛸️','🥌','🎿','⛷️','🏂','🪂','🏋️','🏋️‍♂️','🏋️‍♀️','🤼','🤼‍♂️','🤼‍♀️','🤸','🤸‍♂️','🤸‍♀️','⛹️','⛹️‍♂️','⛹️‍♀️','🤺','🤾','🤾‍♂️','🤾‍♀️','🏌️','🏌️‍♂️','🏌️‍♀️','🏇','🧘','🧘‍♂️','🧘‍♀️','🏄','🏄‍♂️','🏄‍♀️','🏊','🏊‍♂️','🏊‍♀️','🤽','🤽‍♂️','🤽‍♀️','🚣','🚣‍♂️','🚣‍♀️','🧗','🧗‍♂️','🧗‍♀️','🚵','🚵‍♂️','🚵‍♀️','🚴','🚴‍♂️','🚴‍♀️','🏆','🥇','🥈','🥉','🏅','🎖️','🏵️','🎗️'],
  travel: ['🚗','🚕','🚙','🚌','🚎','🏎️','🚓','🚑','🚒','🚐','🛻','🚚','🚛','🚜','🏍️','🛵','🚲','🛴','🛹','🛼','🚁','🛸','✈️','🛩️','🛫','🛬','🪂','💺','🚀','🛰️','🚉','🚊','🚝','🚞','🚋','🚃','🚋','🚞','🚝','🚄','🚅','🚈','🚂','🚆','🚇','🚊','🚉','✈️','🛫','🛬','🛩️','💺','🛰️','🚀','🛸','🚁','🚟','🚠','🚡','🛶','🚤','🛳️','⛴️','🛥️','🚢','⚓','⛵','🪝','🏊','🏄','🏝️','🗿','🗼','🗽','🏛️','🏰','🏯','🏟️','🎡','🎢','🎠','⛱️','🏖️','🏞️','🌋','⛰️','🏔️','🗻','🏕️','⛺','🏠','🏡','🏘️','🏚️','🏗️','🏭','🏢','🏬','🏣','🏤','🏥','🏦','🏨','🏪','🏫','🏩','💒','🏛️','⛪','🕌','🕍','🛕'],
  objects: ['⌚','📱','📲','💻','⌨️','🖥️','🖨️','🖱️','🖲️','🕹️','🗜️','💽','💾','💿','📀','📼','📷','📸','📹','📽️','🎞️','📞','☎️','📟','📠','📺','📻','🎙️','🎚️','🎛️','🧭','⏱️','⏲️','⏰','🕰️','⌛','⏳','📡','🔋','🔌','💡','🔦','🕯️','🪔','🧯','🛢️','💸','💵','💴','💶','💷','💰','💳','💎','⚖️','🧰','🔧','🔨','⚒️','🛠️','⛏️','🔩','⚙️','🧱','⛓️','🧲','🔫','💣','🧨','🪓','🔪','🗡️','⚔️','🛡️','🚬','⚰️','🪦','⚱️','🏺','🔮','📿','🧿','💈','⚗️','🔭','🔬','🕳️','🩹','🩺','💊','💉','🧬','🦠','🧫','🧪','🌡️','🧹','🧺','🧻','🚽','🚰','🚿','🛁','🛀','🧼','🪒','🧽','🧴','🛎️','🔑','🗝️','🚪','🪑','🛋️','🛏️','🛌','🧸','🖼️','🛍️','🛒','🎁','🎈','🎏','🎀','🎊','🎉','🎎','🏮','🎐','🧧','✉️','📩','📨','📧','💌','📥','📤','📦','🏷️','📪','📫','📬','📭','📮','📯','📜','📃','📄','📑','📊','📈','📉','🗒️','🗓️','📆','📅','📇','🗃️','🗳️','🗄️','📋','📁','📂','🗂️','🗞️','📰','📓','📔','📒','📕','📗','📘','📙','📚','📖','🔖','🧷','🔗','📎','🖇️','📐','📏','🧮','📌','📍','✂️','🖊️','🖋️','✒️','🖌️','🖍️','📝','✏️','🔍','🔎','🔏','🔐','🔒','🔓'],
  symbols: ['❤️','🧡','💛','💚','💙','💜','🖤','🤍','🤎','💔','❣️','💕','💞','💓','💗','💖','💘','💝','💟','☮️','✝️','☪️','🕉️','☸️','✡️','🔯','🕎','☯️','☦️','🛐','⛎','♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓','🆔','⚛️','🉑','☢️','☣️','📴','📳','🈶','🈚','🈸','🈺','🈷️','✴️','🆚','💮','🉐','㊙️','㊗️','🈴','🈵','🈹','🈲','🅰️','🅱️','🆎','🆑','🅾️','🆘','❌','⭕','🛑','⛔','📛','🚫','💯','💢','♨️','🚷','🚯','🚳','🚱','🔞','📵','🚭','❗','❕','❓','❔','‼️','⁉️','🔅','🔆','〽️','⚠️','🚸','🔱','⚜️','🔰','♻️','✅','🈯','💹','❇️','✳️','❎','🌐','💠','Ⓜ️','🌀','💤','🏧','🚾','♿','🅿️','🈳','🈂️','🛂','🛃','🛄','🛅','🚹','🚺','🚼','🚻','🚮','🎦','📶','🈁','🔣','ℹ️','🔤','🔡','🔠','🆖','🆗','🆙','🆒','🆕','🆓','0️⃣','1️⃣','2️⃣','3️⃣','4️⃣','5️⃣','6️⃣','7️⃣','8️⃣','9️⃣','🔟']
};

// Loading state management
let loadingState = {
  auth: false,
  profile: false,
  users: false,
  statuses: false,
  previews: false,
  blocked: false,
  friends: false,
  requests: false
};

const el = (id)=>document.getElementById(id);
const splashScreen = el("splashScreen");
const splashStatus = el("splashStatus");
const pinOverlay = el("pinOverlay");
const pinSubtitle = el("pinSubtitle");
const pinDigits = document.querySelectorAll(".pin-digit");
const pinCancel = el("pinCancel");
const pinConfirm = el("pinConfirm");
const pinError = el("pinError");
const meAvatar = el("meAvatar");
const meName = el("meName");
const meEmail = el("meEmail");
const chatList = el("chatList");
const friendsList = el("friendsList");
const searchChats = el("searchChats");
const searchFriends = el("searchFriends");
const chatBack = el("chatBack");
const chatAvatar = el("chatAvatar");
const chatName = el("chatName");
const chatStatus = el("chatStatus");
const chatDot = el("chatDot");
const messagesEl = el("messages");
const composer = el("composer");
const textInput = el("textInput");
const btnSend = el("btnSend");
const btnAttachment = el("btnAttachment");
const attachmentMenu = el("attachmentMenu");
const optionImage = el("optionImage");
const optionVideoLink = el("optionVideoLink");
const optionEmoji = el("optionEmoji");
const emojiPicker = el("emojiPicker");
const emojiGrid = el("emojiGrid");
const imageInput = el("imageInput");
const videoModal = el("videoModal");
const videoLinkInput = el("videoLinkInput");
const videoModalCancel = el("videoModalCancel");
const videoModalSend = el("videoModalSend");
const viewer = el("viewer");
const viewerImg = el("viewerImg");
const viewerClose = el("viewerClose");
const avatarViewer = el("avatarViewer");
const avatarViewerImg = el("avatarViewerImg");
const avatarViewerClose = el("avatarViewerClose");
const avatarViewerName = el("avatarViewerName");
const authModal = el("auth");
const btnGoogle = el("btnGoogle");
const btnAnon = el("btnAnon");
const profileModal = el("profile");
const pName = el("pName");
const pAvatar = el("pAvatar");
const pFile = el("pFile");
const pSave = el("pSave");
const pClose = el("pClose");
const btnEdit = el("btnEdit");
const btnLogout = el("btnLogout");
const toastContainer = el("toastContainer");
const btnBlocked = el("btnBlocked");
const blockedModal = el("blockedModal");
const closeBlockedModal = el("closeBlockedModal");
const blockedList = el("blockedList");
const blockBtn = el("blockBtn");
const unblockBtn = el("unblockBtn");
const pinEnabled = el("pinEnabled");
const pinSetup = el("pinSetup");
const newPin = el("newPin");
const btnNotif = el("btnNotif");
const friendsTab = el("friendsTab");
const friendRequestBadge = el("friendRequestBadge");

// Message processing functions
function linkify(text){
  return text.replace(/(https?:\/\/[^\s]+)/g,'<a class="link" href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
}

// Function to process text messages - preserves line breaks and linkifies
function processTextMessage(text) {
  // First preserve line breaks by converting \n to <br>
  let processedText = text.replace(/\n/g, '<br>');
  
  // Then linkify URLs (but don't convert to video players)
  processedText = linkify(processedText);
  
  return processedText;
}

// Function to process video links for video-link messages
function processVideoPlayer(videoUrl) {
  // YouTube patterns
  const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/;
  
  // Direct video file patterns
  const directVideoRegex = /(https?:\/\/[^\s]+\.(mp4|webm|ogg|mov|avi|mkv)(\?[^\s]*)?)/i;
  
  // Check for YouTube videos
  const youtubeMatch = videoUrl.match(youtubeRegex);
  if (youtubeMatch) {
    const videoId = youtubeMatch[1];
    const embedUrl = `https://www.youtube.com/embed/${videoId}`;
    return `<iframe 
      width="100%" 
      height="250" 
      src="${embedUrl}" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen
      style="border-radius: 10px; margin: 6px 0;">
    </iframe>`;
  }
  
  // Check for direct video links
  const directMatch = videoUrl.match(directVideoRegex);
  if (directMatch) {
    return `<video 
      controls 
      style="max-width: 100%; border-radius: 10px; margin: 6px 0;"
      preload="metadata">
      <source src="${videoUrl}" type="video/${directMatch[2]}">
      Seu navegador não suporta vídeos.
    </video>`;
  }
  
  // If not a recognized video format, return as link
  return `<a class="link" href="${videoUrl}" target="_blank" rel="noopener noreferrer">${videoUrl}</a>`;
}

// Video Modal Functions
function showVideoModal() {
  videoModal.style.display = 'flex';
  videoLinkInput.value = '';
  videoLinkInput.focus();
}

function hideVideoModal() {
  videoModal.style.display = 'none';
  videoLinkInput.value = '';
}

// Video modal event listeners
videoModalCancel.onclick = hideVideoModal;

videoModalSend.onclick = () => {
  const url = videoLinkInput.value.trim();
  if (!url || !currentChat) {
    hideVideoModal();
    return;
  }
  
  // Validate URL
  try {
    new URL(url);
  } catch {
    showToast('URL inválida. Verifique o link e tente novamente.', 'error');
    return;
  }
  
  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  sendMessage({type: "video-link", url: url, id: messageId});
  hideVideoModal();
  showToast('Link de vídeo enviado! 🎥', 'success');
};

// Close modal when clicking outside
videoModal.onclick = (e) => {
  if (e.target === videoModal) {
    hideVideoModal();
  }
};

// Enter key to send video link
videoLinkInput.onkeydown = (e) => {
  if (e.key === 'Enter') {
    videoModalSend.click();
  }
};

// Emoji Picker Functions
function initEmojiPicker() {
  // Initialize with smileys category
  renderEmojiGrid('smileys');
  
  // Category buttons
  document.querySelectorAll('.emoji-category').forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll('.emoji-category').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderEmojiGrid(btn.dataset.category);
    };
  });
}

function renderEmojiGrid(category) {
  emojiGrid.innerHTML = '';
  const emojis = emojiCategories[category] || [];
  
  emojis.forEach(emoji => {
    const btn = document.createElement('button');
    btn.className = 'emoji-item';
    btn.textContent = emoji;
    btn.onclick = () => insertEmoji(emoji);
    emojiGrid.appendChild(btn);
  });
}

function insertEmoji(emoji) {
  const cursorPos = textInput.selectionStart;
  const textBefore = textInput.value.substring(0, cursorPos);
  const textAfter = textInput.value.substring(cursorPos);
  
  textInput.value = textBefore + emoji + textAfter;
  textInput.focus();
  textInput.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
  
  hideEmojiPicker();
}

function showEmojiPicker() {
  emojiPicker.classList.add('show');
}

function hideEmojiPicker() {
  emojiPicker.classList.remove('show');
}

// Attachment Menu Functions
function showAttachmentMenu() {
  attachmentMenu.classList.add('show');
}

function hideAttachmentMenu() {
  attachmentMenu.classList.remove('show');
}

// Attachment button events
btnAttachment.onclick = (e) => {
  e.stopPropagation();
  if (attachmentMenu.classList.contains('show')) {
    hideAttachmentMenu();
  } else {
    hideEmojiPicker(); // Close emoji picker if open
    showAttachmentMenu();
  }
};

// Attachment menu options
optionImage.onclick = () => {
  hideAttachmentMenu();
  imageInput.click();
};

optionVideoLink.onclick = () => {
  hideAttachmentMenu();
  showVideoModal();
};

optionEmoji.onclick = () => {
  hideAttachmentMenu();
  showEmojiPicker();
};

// Close attachment menu and emoji picker when clicking outside
document.addEventListener('click', (e) => {
  if (!attachmentMenu.contains(e.target) && e.target !== btnAttachment) {
    hideAttachmentMenu();
  }
  if (!emojiPicker.contains(e.target) && e.target !== btnAttachment && !attachmentMenu.contains(e.target)) {
    hideEmojiPicker();
  }
});

// Tab Navigation
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.onclick = () => switchTab(btn.dataset.tab);
});

function switchTab(tabName) {
  currentTab = tabName;
  
  // Update tab buttons
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tabName);
  });
  
  // Update tab content
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.toggle('active', content.id === tabName);
  });
  
  // Clear search when switching tabs
  if (tabName === 'my-chats') {
    searchChats.value = '';
    filterChatList();
  } else {
    searchFriends.value = '';
    filterFriendsList();
  }
}

// Avatar Viewer Functions
function openAvatarViewer(src, name) {
  if (!src || src.includes('data:image/svg')) return;
  
  avatarViewerImg.src = src;
  avatarViewerName.textContent = name || 'Usuário';
  avatarViewer.style.display = 'flex';
}

avatarViewerClose.onclick = () => {
  avatarViewer.style.display = 'none';
  avatarViewerImg.src = '';
};

avatarViewer.onclick = (e) => {
  if (e.target === avatarViewer) {
    avatarViewer.style.display = 'none';
    avatarViewerImg.src = '';
  }
};

// Update splash status
function updateSplashStatus(message) {
  splashStatus.textContent = message;
  console.log('📍 Loading:', message);
}

// Check if all data is loaded
function checkAllDataLoaded() {
  const allLoaded = Object.values(loadingState).every(state => state);
  console.log('📊 Loading state:', loadingState, 'All loaded:', allLoaded);
  
  if (allLoaded) {
    updateSplashStatus('Tudo pronto! Abrindo aplicação...');
    setTimeout(() => {
      hideSplashScreen();
    }, 800);
  }
}

// PIN Security System
let appPin = localStorage.getItem('chatPin') || null;
let pinMode = 'verify'; // 'verify' or 'setup'
let currentPinInput = '';
let pinAuthenticated = false;

function initPinSystem() {
  const pinEnabledStored = localStorage.getItem('pinEnabled') === 'true';
  pinEnabled.checked = pinEnabledStored;
  
  pinEnabled.onchange = () => {
    if (pinEnabled.checked) {
      pinSetup.style.display = 'block';
    } else {
      pinSetup.style.display = 'none';
      localStorage.removeItem('chatPin');
      localStorage.removeItem('pinEnabled');
      appPin = null;
    }
  };
  
  // Check if PIN is required
  if (pinEnabledStored && appPin && !pinAuthenticated) {
    // Wait for splash to finish, then show PIN
    setTimeout(() => {
      if (Object.values(loadingState).every(state => state)) {
        showPinOverlay('verify');
      }
    }, 2000);
  }
}

function showPinOverlay(mode) {
  pinMode = mode;
  currentPinInput = '';
  
  if (mode === 'verify') {
    pinSubtitle.textContent = 'Digite seu PIN para acessar o app';
  } else {
    pinSubtitle.textContent = 'Defina um PIN de 4 dígitos';
  }
  
  pinDigits.forEach(digit => {
    digit.value = '';
    digit.classList.remove('filled');
  });
  
  pinError.style.display = 'none';
  pinOverlay.style.display = 'flex';
  pinDigits[0].focus();
}

function hidePinOverlay() {
  pinOverlay.style.display = 'none';
  pinAuthenticated = true;
  
  // If PIN was being verified and is now authenticated, ensure splash is hidden
  if (pinMode === 'verify' && Object.values(loadingState).every(state => state)) {
    hideSplashScreen();
  }
}

// PIN input handling
pinDigits.forEach((digit, index) => {
  digit.oninput = (e) => {
    const value = e.target.value;
    if (value && /^\d$/.test(value)) {
      digit.classList.add('filled');
      if (index < 3) {
        pinDigits[index + 1].focus();
      }
      updatePinInput();
    }
  };
  
  digit.onkeydown = (e) => {
    if (e.key === 'Backspace' && !digit.value && index > 0) {
      pinDigits[index - 1].focus();
      pinDigits[index - 1].value = '';
      pinDigits[index - 1].classList.remove('filled');
      updatePinInput();
    }
  };
});

function updatePinInput() {
  currentPinInput = Array.from(pinDigits).map(d => d.value).join('');
  if (currentPinInput.length === 4) {
    if (pinMode === 'verify') {
      verifyPin();
    }
  }
}

function verifyPin() {
  if (currentPinInput === appPin) {
    hidePinOverlay();
  } else {
    showPinError();
  }
}

function showPinError() {
  pinError.style.display = 'block';
  pinDigits.forEach(digit => {
    digit.value = '';
    digit.classList.remove('filled');
  });
  currentPinInput = '';
  pinDigits[0].focus();
}

pinConfirm.onclick = () => {
  if (currentPinInput.length === 4) {
    if (pinMode === 'verify') {
      verifyPin();
    }
  }
};

pinCancel.onclick = () => {
  if (pinMode === 'verify') {
    // Force reload if user cancels PIN verification
    location.reload();
  } else {
    hidePinOverlay();
  }
};

// Splash Screen
function hideSplashScreen() {
  // Only hide if PIN is not required or is authenticated
  const pinRequired = localStorage.getItem('pinEnabled') === 'true' && appPin;
  
  if (!pinRequired || pinAuthenticated) {
    splashScreen.classList.add('hidden');
    document.body.style.overflow = 'auto';
    console.log('🎉 App ready and splash hidden');
  }
}

// Sistema de notificação para Android
function triggerAndroidNotification() {
  try {
    if (btnNotif && typeof btnNotif.click === 'function') {
      btnNotif.click();
      console.log('🔔 Notificação Android disparada');
    }
  } catch (error) {
    console.log('Notificação Android não disponível:', error);
  }
}

// Sistema de notificação sonora usando Web Audio API
function createNotificationSound(frequency, duration) {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    oscillator.type = 'sine';
    
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
  } catch (error) {
    console.log('Audio notification not available');
  }
}

// Sistema de Toast
function showToast(message, type = 'info', duration = 3000) {
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.textContent = message;
  toastContainer.appendChild(toast);
  
  setTimeout(() => {
    toast.style.animation = 'slideOut 0.3s ease forwards';
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

// Dark mode
if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
  document.body.classList.add('dark');
}

window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
  if (event.matches) {
    document.body.classList.add('dark');
  } else {
    document.body.classList.remove('dark');
  }
});

// Função para gerar avatar com iniciais
function getDefaultAvatar(name) {
  const initials = (name || "U").split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
  const colors = ['#1a73e8', '#34a853', '#ea4335', '#fbbc04', '#9c27b0', '#ff5722', '#607d8b', '#795548'];
  const colorIndex = (name || "U").charCodeAt(0) % colors.length;
  const color = colors[colorIndex];
  
  return `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'><circle cx='32' cy='32' r='32' fill='${encodeURIComponent(color)}'/><text x='32' y='38' text-anchor='middle' fill='white' font-family='Arial,sans-serif' font-size='20' font-weight='bold'>${encodeURIComponent(initials)}</text></svg>`;
}

// Função para carregar avatar com fallback robusto
function loadAvatar(imgElement, avatarUrl, userName) {
  if (!imgElement) return;
  
  imgElement.classList.remove('loaded');
  
  if (avatarUrl && avatarUrl.trim() && avatarUrl !== 'null' && avatarUrl !== 'undefined') {
    const testImg = new Image();
    testImg.onload = () => {
      imgElement.src = avatarUrl;
      imgElement.classList.add('loaded');
      imgElement.textContent = '';
    };
    testImg.onerror = () => {
      setAvatarWithInitials(imgElement, userName);
    };
    testImg.src = avatarUrl;
  } else {
    setAvatarWithInitials(imgElement, userName);
  }
}

function setAvatarWithInitials(imgElement, userName) {
  const initials = (userName || "U").split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
  imgElement.src = getDefaultAvatar(userName);
  imgElement.classList.add('loaded');
  imgElement.onerror = () => {
    imgElement.style.display = 'flex';
    imgElement.textContent = initials;
    imgElement.src = '';
  };
}

// Upload de imagem
async function uploadToImgBB(file) {
  try {
    const formData = new FormData();
    formData.append('image', file);
    
    const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_KEY}`, {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }
    
    const data = await response.json();
    if (data.success) {
      return data.data.url;
    } else {
      throw new Error(data.error?.message || 'Falha no upload');
    }
  } catch (error) {
    console.error('Erro no upload ImgBB:', error);
    throw error;
  }
}

// Friend Request System
async function sendFriendRequest(userId) {
  try {
    const timestamp = now();
    await db.ref(`friendRequests/${userId}/${me.uid}`).set({
      from: me.uid,
      timestamp: timestamp,
      status: 'pending'
    });
    
    // Add to our sent requests
    await db.ref(`sentRequests/${me.uid}/${userId}`).set({
      to: userId,
      timestamp: timestamp,
      status: 'pending'
    });
    
    showToast('Pedido de amizade enviado! 📤', 'success');
    renderFriendsList();
  } catch (error) {
    console.error('Erro ao enviar pedido de amizade:', error);
    showToast('Erro ao enviar pedido de amizade', 'error');
  }
}

async function acceptFriendRequest(userId) {
  try {
    // Add both users to each other's friend lists
    await db.ref(`friendsInChat/${me.uid}/${userId}`).set(true);
    await db.ref(`friendsInChat/${userId}/${me.uid}`).set(true);
    
    // Remove the request
    await db.ref(`friendRequests/${me.uid}/${userId}`).remove();
    await db.ref(`sentRequests/${userId}/${me.uid}`).remove();
    
    showToast('Pedido de amizade aceito! 🎉', 'success');
    renderChatList();
    renderFriendsList();
    updateFriendRequestBadge();
  } catch (error) {
    console.error('Erro ao aceitar pedido de amizade:', error);
    showToast('Erro ao aceitar pedido de amizade', 'error');
  }
}

async function declineFriendRequest(userId) {
  try {
    // Remove the request
    await db.ref(`friendRequests/${me.uid}/${userId}`).remove();
    await db.ref(`sentRequests/${userId}/${me.uid}`).remove();
    
    showToast('Pedido de amizade recusado', 'info');
    renderFriendsList();
    updateFriendRequestBadge();
  } catch (error) {
    console.error('Erro ao recusar pedido de amizade:', error);
    showToast('Erro ao recusar pedido de amizade', 'error');
  }
}

async function removeFriendFromChat(userId) {
  try {
    await db.ref(`friendsInChat/${me.uid}/${userId}`).remove();
    await db.ref(`friendsInChat/${userId}/${me.uid}`).remove();
    delete friendsInChat[userId];
    showToast('Amigo removido do chat', 'info');
    renderChatList();
    renderFriendsList();
  } catch (error) {
    console.error('Erro ao remover amigo do chat:', error);
    showToast('Erro ao remover amigo', 'error');
  }
}

function isFriendInChat(userId) {
  return friendsInChat && friendsInChat[userId] === true;
}

function hasSentRequest(userId) {
  return friendRequests[userId] && friendRequests[userId].status === 'pending';
}

function hasReceivedRequest(userId) {
  return receivedRequests[userId] && receivedRequests[userId].status === 'pending';
}

function updateFriendRequestBadge() {
  const requestCount = Object.keys(receivedRequests).filter(uid => 
    receivedRequests[uid].status === 'pending'
  ).length;
  
  if (requestCount > 0) {
    friendRequestBadge.textContent = requestCount;
    friendRequestBadge.style.display = 'inline';
  } else {
    friendRequestBadge.style.display = 'none';
  }
}

// Função para verificar se usuário está bloqueado
function isUserBlocked(userId) {
  return blockedUsers && blockedUsers[userId] === true;
}

// Função para bloquear usuário
async function blockUser(userId) {
  try {
    await db.ref(`blocked/${me.uid}/${userId}`).set(true);
    blockedUsers[userId] = true;
    showToast('Usuário bloqueado com sucesso', 'success');
    renderChatList();
    renderFriendsList();
    updateBlockButtons();
  } catch (error) {
    console.error('Erro ao bloquear usuário:', error);
    showToast('Erro ao bloquear usuário', 'error');
  }
}

// Função para desbloquear usuário
async function unblockUser(userId) {
  try {
    await db.ref(`blocked/${me.uid}/${userId}`).remove();
    delete blockedUsers[userId];
    showToast('Usuário desbloqueado com sucesso', 'success');
    renderChatList();
    renderFriendsList();
    updateBlockButtons();
    renderBlockedUsers();
  } catch (error) {
    console.error('Erro ao desbloquear usuário:', error);
    showToast('Erro ao desbloquear usuário', 'error');
  }
}

// Função para mostrar modal de confirmação personalizado
function showConfirmDialog(message, onConfirm) {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1400;
    backdrop-filter: blur(4px);
  `;
  
  modal.innerHTML = `
    <div style="
      background: var(--card);
      border-radius: 16px;
      padding: 24px;
      max-width: 400px;
      width: calc(100% - 40px);
      box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3);
    ">
      <p style="
        color: var(--text);
        margin: 0 0 20px 0;
        font-size: 16px;
        line-height: 1.5;
      ">${message}</p>
      <div style="
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      ">
        <button id="cancelBtn" style="
          padding: 10px 20px;
          border: 1px solid var(--line);
          background: transparent;
          color: var(--text);
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
          transition: all 0.2s ease;
        ">Cancelar</button>
        <button id="confirmBtn" style="
          padding: 10px 20px;
          background: #ef4444;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
          transition: all 0.2s ease;
        ">Confirmar</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Event listeners
  modal.querySelector('#cancelBtn').onclick = () => {
    document.body.removeChild(modal);
  };
  
  modal.querySelector('#confirmBtn').onclick = () => {
    document.body.removeChild(modal);
    onConfirm();
  };
  
  // Fechar clicando fora
  modal.onclick = (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  };
}

// Atualizar botões de bloquear/desbloquear
function updateBlockButtons() {
  if (currentChatUser) {
    const isBlocked = isUserBlocked(currentChatUser.uid);
    blockBtn.style.display = isBlocked ? 'none' : 'block';
    unblockBtn.style.display = isBlocked ? 'block' : 'none';
  } else {
    blockBtn.style.display = 'none';
    unblockBtn.style.display = 'none';
  }
}

// Renderizar lista de usuários bloqueados
function renderBlockedUsers() {
  blockedList.innerHTML = '';
  
  const blockedUserIds = Object.keys(blockedUsers).filter(uid => blockedUsers[uid]);
  
  if (blockedUserIds.length === 0) {
    blockedList.innerHTML = '<p style="text-align:center;color:var(--muted);padding:20px">Nenhum usuário bloqueado</p>';
    return;
  }
  
  blockedUserIds.forEach(userId => {
    const user = usersCache[userId];
    if (!user) return;
    
    const item = document.createElement('div');
    item.className = 'blocked-item';
    
    const avatar = document.createElement('img');
    avatar.className = 'avatar';
    loadAvatar(avatar, user.avatar, user.name);
    
    const info = document.createElement('div');
    info.className = 'info';
    
    const name = document.createElement('div');
    name.className = 'name';
    name.textContent = user.name || 'Usuário';
    
    const email = document.createElement('div');
    email.className = 'email';
    email.textContent = user.email || 'Email não disponível';
    
    info.appendChild(name);
    info.appendChild(email);
    
    const unblockButton = document.createElement('button');
    unblockButton.className = 'unblock-btn';
    unblockButton.textContent = 'Desbloquear';
    unblockButton.onclick = () => unblockUser(userId);
    
    item.appendChild(avatar);
    item.appendChild(info);
    item.appendChild(unblockButton);
    
    blockedList.appendChild(item);
  });
}

// Message Status System
function updateMessageStatus(messageId, status) {
  messageStatusCache[messageId] = status;
  
  // Update UI
  const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
  if (messageElement) {
    const statusElement = messageElement.querySelector('.message-status');
    if (statusElement) {
      statusElement.className = `message-status ${status}`;
      statusElement.textContent = getStatusIcon(status);
    }
  }
}

function getStatusIcon(status) {
  switch (status) {
    case 'sent': return '✓';
    case 'delivered': return '✓✓';
    case 'read': return '✓✓';
    default: return '';
  }
}

// Delete Message Function
async function deleteMessage(messageKey, messageId) {
  try {
    const cid = chatId(me.uid, currentChat);
    
    // Remove from Firebase
    await db.ref(`chats/${cid}/${messageKey}`).remove();
    
    // Remove from UI
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      messageElement.remove();
    }
    
    showToast('Mensagem apagada', 'info');
  } catch (error) {
    console.error('Erro ao apagar mensagem:', error);
    showToast('Erro ao apagar mensagem', 'error');
  }
}

function goToHome() {
  document.querySelector('.sidebar').classList.add('active');
  document.querySelector('.chat').classList.remove('active');
  currentChat = null;
  currentChatUser = null;
  composer.style.display = 'none';
  chatName.textContent = 'Selecione um usuário';
  chatStatus.textContent = '--';
  chatDot.className = 'dot offline';
  updateBlockButtons();
}

function now(){ return Date.now(); }
function chatId(a,b){ return a<b ? a+"_"+b : b+"_"+a; }
function formatTime(ts){
  try{
    const d=new Date(ts); 
    return d.toLocaleTimeString([], {hour:"2-digit",minute:"2-digit"});
  }catch{ return "" }
}

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
  updateSplashStatus('Iniciando sistema de segurança...');
  initPinSystem();
  initEmojiPicker();
});

auth.onAuthStateChanged(async user=>{
  if(user){
    me = user;
    loadingState.auth = true;
    authModal.style.display = "none";
    updateSplashStatus('Carregando perfil do usuário...');
    await ensureProfile();
    bindPresence();
    bindUsers();
    bindStatuses();
    bindPreviews();
    bindBlockedUsers();
    bindFriendsInChat();
    bindFriendRequests();
    bindMessageStatus();
    checkAllDataLoaded();
  }else{
    authModal.style.display = "flex";
    splashScreen.classList.add('hidden');
  }
});

// Bind para amigos no chat
function bindFriendsInChat() {
  updateSplashStatus('Carregando lista de amigos...');
  db.ref(`friendsInChat/${me.uid}`).on('value', (snapshot) => {
    friendsInChat = snapshot.val() || {};
    loadingState.friends = true;
    console.log('👥 Amigos no chat carregados:', friendsInChat);
    renderChatList();
    renderFriendsList();
    checkAllDataLoaded();
  });
}

// Bind para pedidos de amizade
function bindFriendRequests() {
  updateSplashStatus('Carregando pedidos de amizade...');
  
  // Bind received requests
  db.ref(`friendRequests/${me.uid}`).on('value', (snapshot) => {
    receivedRequests = snapshot.val() || {};
    console.log('📥 Pedidos recebidos:', receivedRequests);
    renderFriendsList();
    updateFriendRequestBadge();
  });
  
  // Bind sent requests
  db.ref(`sentRequests/${me.uid}`).on('value', (snapshot) => {
    friendRequests = snapshot.val() || {};
    loadingState.requests = true;
    console.log('📤 Pedidos enviados:', friendRequests);
    renderFriendsList();
    checkAllDataLoaded();
  });
}

// Bind para usuários bloqueados
function bindBlockedUsers() {
  updateSplashStatus('Carregando usuários bloqueados...');
  db.ref(`blocked/${me.uid}`).on('value', (snapshot) => {
    blockedUsers = snapshot.val() || {};
    loadingState.blocked = true;
    console.log('Usuários bloqueados carregados:', blockedUsers);
    renderChatList();
    renderFriendsList();
    updateBlockButtons();
    checkAllDataLoaded();
  });
}

// Bind para status das mensagens
function bindMessageStatus() {
  db.ref(`messageStatus/${me.uid}`).on('value', (snapshot) => {
    const statuses = snapshot.val() || {};
    Object.keys(statuses).forEach(messageId => {
      updateMessageStatus(messageId, statuses[messageId]);
    });
  });
}

btnGoogle.onclick = async ()=>{
  try{
    updateSplashStatus('Conectando com Google...');
    const provider = new firebase.auth.GoogleAuthProvider();
    const result = await auth.signInWithPopup(provider);
    if(result.user && result.user.displayName && result.user.photoURL) {
      const userData = {
        name: result.user.displayName,
        avatar: result.user.photoURL,
        lastSeen: now()
      };
      await db.ref("users/"+result.user.uid).update(userData);
    }
  }catch(e){ 
    console.error("Erro no login Google:", e);
    showToast("Falha no login Google: "+e.message, 'error'); 
  }
};

btnAnon.onclick = async ()=>{
  try{ 
    updateSplashStatus('Conectando anonimamente...');
    await auth.signInAnonymously(); 
  }
  catch(e){ 
    console.error("Erro no login anônimo:", e);
    showToast("Falha no login anônimo: "+e.message, 'error'); 
  }
};

btnLogout.onclick = async()=>{ 
  await auth.signOut(); 
  location.reload(); 
};

btnEdit.onclick = ()=> openProfile();
pClose.onclick = ()=> profileModal.style.display = "none";
chatBack.onclick = ()=> goToHome();

// Event listeners para bloqueio
btnBlocked.onclick = () => {
  blockedModal.style.display = "flex";
  renderBlockedUsers();
};

closeBlockedModal.onclick = () => {
  blockedModal.style.display = "none";
};

blockBtn.onclick = () => {
  if (currentChatUser) {
    showConfirmDialog(`Tem certeza que deseja bloquear ${currentChatUser.name}?`, () => {
      blockUser(currentChatUser.uid);
    });
  }
};

unblockBtn.onclick = () => {
  if (currentChatUser) {
    showConfirmDialog(`Tem certeza que deseja desbloquear ${currentChatUser.name}?`, () => {
      unblockUser(currentChatUser.uid);
    });
  }
};

// Search functionality
searchChats.oninput = () => filterChatList();
searchFriends.oninput = () => filterFriendsList();

pFile.onchange = async (e)=>{
  const file = e.target.files[0]; 
  if(!file) return;
  
  if (file.size > 5 * 1024 * 1024) {
    showToast('Arquivo muito grande! Máximo 5MB.', 'error');
    return;
  }

  if (!file.type.startsWith('image/')) {
    showToast('Selecione apenas arquivos de imagem.', 'error');
    return;
  }
  
  try {
    showToast('Enviando foto...', 'info');
    const url = await uploadToImgBB(file);
    if(url){ 
      pAvatar.value = url;
      loadAvatar(meAvatar, url, pName.value || meProfile?.name || "Usuário");
      showToast('Foto enviada com sucesso! 📸', 'success');
    }
  } catch(error) {
    console.error("Erro ao fazer upload:", error);
    showToast("Erro ao fazer upload da imagem", 'error');
  }
};

pSave.onclick = async ()=>{
  const name = pName.value.trim() || "Usuário";
  const avatar = pAvatar.value.trim();
  
  // Handle PIN setup
  if (pinEnabled.checked && newPin.value.trim()) {
    const pin = newPin.value.trim();
    if (pin.length === 4 && /^\d{4}$/.test(pin)) {
      localStorage.setItem('chatPin', pin);
      localStorage.setItem('pinEnabled', 'true');
      appPin = pin;
      pinAuthenticated = true; // Important: mark as authenticated when setting new PIN
      showToast('PIN definido com sucesso! 🔐', 'success');
    } else {
      showToast('PIN deve ter exatamente 4 dígitos', 'error');
      return;
    }
  } else if (!pinEnabled.checked) {
    localStorage.removeItem('chatPin');
    localStorage.removeItem('pinEnabled');
    appPin = null;
    pinAuthenticated = true; // No PIN required
  }
  
  try {
    const updates = { name, avatar, lastSeen: now() };
    await db.ref("users/"+me.uid).update(updates);
    
    await me.updateProfile({ 
      displayName: name, 
      photoURL: avatar || null 
    }).catch(()=>{});
    
    meProfile = {uid:me.uid, ...updates};
    renderMe();
    profileModal.style.display = "none";
    showToast("Perfil atualizado com sucesso!", 'success');
  } catch(error) {
    console.error("Erro ao salvar perfil:", error);
    showToast("Erro ao salvar perfil", 'error');
  }
};

async function ensureProfile(){
  try {
    const snap = await db.ref("users/"+me.uid).get();
    let profile = snap.val();
    
    if(!profile){
      profile = { 
        uid: me.uid, 
        name: me.displayName || "Usuário", 
        avatar: me.photoURL || "", 
        lastSeen: now() 
      };
      await db.ref("users/"+me.uid).set(profile);
    } else {
      const needsUpdate = {};
      if(me.displayName && me.displayName !== profile.name) {
        needsUpdate.name = me.displayName;
      }
      if(me.photoURL && me.photoURL !== profile.avatar) {
        needsUpdate.avatar = me.photoURL;
      }
      if(Object.keys(needsUpdate).length > 0) {
        needsUpdate.lastSeen = now();
        await db.ref("users/"+me.uid).update(needsUpdate);
        profile = {...profile, ...needsUpdate};
      }
    }
    
    meProfile = profile;
    loadingState.profile = true;
    renderMe();
    
    if(me.displayName !== profile.name || me.photoURL !== (profile.avatar||"")){
      try{ 
        await me.updateProfile({
          displayName: profile.name, 
          photoURL: profile.avatar||null
        }); 
      }catch(e){
        console.warn("Erro ao atualizar auth profile:", e);
      }
    }
    
    if(!profile.name || profile.name==="Usuário"){ 
      openProfile(); 
    }
    
    checkAllDataLoaded();
  } catch(error) {
    console.error("Erro ao carregar perfil:", error);
    showToast("Erro ao carregar perfil", 'error');
  }
}

function renderMe(){
  if(!meProfile) return;
  
  loadAvatar(meAvatar, meProfile.avatar, meProfile.name);
  meName.textContent = meProfile.name || "Usuário";
  meEmail.textContent = me.email || (me.isAnonymous ? "Conectado como Anônimo" : "--");
  pName.value = meProfile.name || "";
  pAvatar.value = meProfile.avatar || "";
}

function openProfile(){ 
  profileModal.style.display = "flex"; 
  if(meProfile) {
    pName.value = meProfile.name || "";
    pAvatar.value = meProfile.avatar || "";
  }
}

function bindPresence(){
  const statusRef = db.ref("status/"+me.uid);
  const isOffline = { 
    state: "offline", 
    lastSeen: firebase.database.ServerValue.TIMESTAMP,
    timestamp: firebase.database.ServerValue.TIMESTAMP 
  };
  const isOnline = { 
    state: "online", 
    lastSeen: firebase.database.ServerValue.TIMESTAMP,
    timestamp: firebase.database.ServerValue.TIMESTAMP 
  };
  
  db.ref(".info/connected").on("value", snap=>{
    if(snap.val() === true){
      console.log('📡 Conectado ao Firebase');
      statusRef.onDisconnect().set(isOffline).then(()=> {
        console.log('📡 OnDisconnect configurado');
        statusRef.set(isOnline).then(() => {
          console.log('📡 Status online definido');
        });
      });
    } else {
      console.log('📡 Desconectado do Firebase');
    }
  });
  
  setInterval(()=> {
    statusRef.update({ 
      lastSeen: firebase.database.ServerValue.TIMESTAMP,
      timestamp: firebase.database.ServerValue.TIMESTAMP 
    });
    db.ref("users/"+me.uid).update({ lastSeen: now() });
  }, 30_000);
}

function bindUsers(){
  updateSplashStatus('Carregando lista de usuários...');
  db.ref("users").on("value", snap=>{
    const all = snap.val() || {};
    usersCache = all;
    loadingState.users = true;
    console.log('👥 Usuários carregados:', Object.keys(all).length);
    const arr = Object.keys(all)
      .filter(uid=>uid!==me.uid)
      .map(uid=>({uid, ...all[uid]}))
      .filter(user => user.name && user.name !== "");
    renderChatList();
    renderFriendsList();
    checkAllDataLoaded();
  });
}

function bindStatuses(){
  updateSplashStatus('Carregando status dos usuários...');
  db.ref("status").on("value", snap=>{
    const statuses = snap.val() || {};
    userStatusCache = statuses;
    loadingState.statuses = true;
    console.log('📊 Status carregados:', Object.keys(statuses).length);
    updateStatusIndicators();
    checkAllDataLoaded();
  });
}

function bindPreviews(){
  updateSplashStatus('Carregando preview das conversas...');
  db.ref("userChats/"+me.uid).on("value", snap=>{
    userPreviewCache = snap.val() || {};
    loadingState.previews = true;
    renderChatList();
    checkAllDataLoaded();
  });
}

// Render Chat List (only friends in chat)
function renderChatList() {
  chatList.innerHTML = "";
  
  const allUsers = Object.keys(usersCache)
    .filter(uid => uid !== me.uid)
    .map(uid => ({uid, ...usersCache[uid]}))
    .filter(user => user.name && user.name !== "");
  
  // Only show friends that are in chat and not blocked
  const chatUsers = allUsers.filter(user => 
    isFriendInChat(user.uid) && !isUserBlocked(user.uid)
  );
  
  chatUsers.sort((a,b)=>{
    const la = userPreviewCache?.[a.uid]?.lastTime || 0;
    const lb = userPreviewCache?.[b.uid]?.lastTime || 0;
    if(lb!==la) return lb-la;
    return (a.name||"").localeCompare(b.name||"");
  });
  
  if (chatUsers.length === 0) {
    chatList.innerHTML = '<p style="text-align:center;color:var(--muted);padding:20px">Nenhum amigo no chat ainda.<br>Adicione amigos na aba "Adicionar Amigos"</p>';
    return;
  }
  
  chatUsers.forEach(u => {
    createUserListItem(u, chatList, 'chat');
  });
  
  filterChatList();
  updateStatusIndicators();
}

// Render Friends List (all users with add/remove/confirm buttons)
function renderFriendsList() {
  friendsList.innerHTML = "";
  
  const allUsers = Object.keys(usersCache)
    .filter(uid => uid !== me.uid)
    .map(uid => ({uid, ...usersCache[uid]}))
    .filter(user => user.name && user.name !== "");
  
  // Show all users except blocked ones
  const availableUsers = allUsers.filter(user => !isUserBlocked(user.uid));
  
  availableUsers.sort((a,b) => {
    return (a.name||"").localeCompare(b.name||"");
  });
  
  if (availableUsers.length === 0) {
    friendsList.innerHTML = '<p style="text-align:center;color:var(--muted);padding:20px">Nenhum usuário disponível</p>';
    return;
  }
  
  availableUsers.forEach(u => {
    createUserListItem(u, friendsList, 'friends');
  });
  
  filterFriendsList();
  updateStatusIndicators();
}

function createUserListItem(user, container, listType) {
  const li = document.createElement("li");
  li.className = "user-item";
  li.dataset.uid = user.uid;

  const img = document.createElement("img");
  img.className = "avatar";
  img.alt = user.name || "Usuário";
  img.onclick = (e) => {
    e.stopPropagation();
    openAvatarViewer(user.avatar, user.name);
  };
  loadAvatar(img, user.avatar, user.name);

  const main = document.createElement("div");
  main.className = "u-main";
  const nm = document.createElement("div"); 
  nm.className = "u-name"; 
  nm.textContent = user.name || "Sem nome";
  
  const pv = document.createElement("div"); 
  pv.className = "u-preview";
  
  if (listType === 'chat') {
    const preview = userPreviewCache?.[user.uid]?.lastText || "";
    pv.innerHTML = preview ? sanitizePreview(preview) : "Nenhuma mensagem ainda";
  } else {
    pv.textContent = user.email || "Usuário disponível";
  }

  main.appendChild(nm); 
  main.appendChild(pv);

  const right = document.createElement("div");
  right.className = "u-right";
  
  if (listType === 'chat') {
    const time = document.createElement("div");
    time.className = "u-time";
    time.textContent = userPreviewCache?.[user.uid]?.lastTime ? 
      formatTime(userPreviewCache?.[user.uid]?.lastTime) : "";
    
    const dot = document.createElement("div");
    const userStatus = userStatusCache?.[user.uid];
    dot.className = "dot " + (userStatus?.state==="online" ? "online":"offline");
    
    right.appendChild(time); 
    right.appendChild(dot);
    
    li.onclick = () => openChat(user.uid, user);
  } else {
    // Friends list - show different actions based on relationship status
    const dot = document.createElement("div");
    const userStatus = userStatusCache?.[user.uid];
    dot.className = "dot " + (userStatus?.state==="online" ? "online":"offline");
    
    if (hasReceivedRequest(user.uid)) {
      // Show accept/decline buttons for received requests
      const actionsDiv = document.createElement("div");
      actionsDiv.className = "request-actions";
      
      const acceptBtn = document.createElement("button");
      acceptBtn.className = "request-btn accept";
      acceptBtn.textContent = "Aceitar";
      acceptBtn.onclick = (e) => {
        e.stopPropagation();
        acceptFriendRequest(user.uid);
      };
      
      const declineBtn = document.createElement("button");
      declineBtn.className = "request-btn decline";
      declineBtn.textContent = "Recusar";
      declineBtn.onclick = (e) => {
        e.stopPropagation();
        declineFriendRequest(user.uid);
      };
      
      actionsDiv.appendChild(acceptBtn);
      actionsDiv.appendChild(declineBtn);
      right.appendChild(actionsDiv);
    } else if (isFriendInChat(user.uid)) {
      // Show remove button for existing friends
      const actionBtn = document.createElement("button");
      actionBtn.className = "friend-action remove";
      actionBtn.textContent = "Remover";
      actionBtn.onclick = (e) => {
        e.stopPropagation();
        removeFriendFromChat(user.uid);
      };
      right.appendChild(actionBtn);
    } else if (hasSentRequest(user.uid)) {
      // Show pending status for sent requests
      const actionBtn = document.createElement("button");
      actionBtn.className = "friend-action pending";
      actionBtn.textContent = "Pendente";
      actionBtn.disabled = true;
      right.appendChild(actionBtn);
    } else {
      // Show add button for new potential friends
      const actionBtn = document.createElement("button");
      actionBtn.className = "friend-action";
      actionBtn.textContent = "Adicionar";
      actionBtn.onclick = (e) => {
        e.stopPropagation();
        sendFriendRequest(user.uid);
      };
      right.appendChild(actionBtn);
    }
    
    right.appendChild(dot);
  }

  li.appendChild(img); 
  li.appendChild(main); 
  li.appendChild(right);
  container.appendChild(li);
}

function sanitizePreview(t){
  const div = document.createElement("div"); 
  div.innerText = t; 
  let s = div.innerText;
  if(s.length>40) s = s.slice(0,40)+"…";
  return s;
}

function filterChatList(){
  const q = (searchChats.value||"").toLowerCase().trim();
  [...chatList.children].forEach(li=>{
    if (li.tagName !== 'LI') return;
    const uid = li.dataset.uid;
    const name = li.querySelector(".u-name").textContent.toLowerCase();
    const preview = (userPreviewCache?.[uid]?.lastText||"").toLowerCase();
    const show = !q || name.includes(q) || preview.includes(q);
    li.style.display = show ? "" : "none";
  });
}

function filterFriendsList(){
  const q = (searchFriends.value||"").toLowerCase().trim();
  [...friendsList.children].forEach(li=>{
    if (li.tagName !== 'LI') return;
    const name = li.querySelector(".u-name").textContent.toLowerCase();
    const show = !q || name.includes(q);
    li.style.display = show ? "" : "none";
  });
}

function updateStatusIndicators(){
  [...chatList.children, ...friendsList.children].forEach(li=>{
    if (li.tagName !== 'LI') return;
    const uid = li.dataset.uid;
    const dot = li.querySelector(".dot");
    if(!dot) return;
    const userStatus = userStatusCache?.[uid];
    dot.className = "dot " + (userStatus?.state==="online" ? "online":"offline");
  });
  
  if(currentChat){
    const st = userStatusCache?.[currentChat];
    chatDot.className = "dot " + (st?.state==="online" ? "online":"offline");
    chatStatus.textContent = st?.state==="online" ? "online" : "offline";
  }
}

let msgListenerRef = null;
function openChat(uid, user){
  currentChat = uid;
  currentChatUser = user;
  chatName.textContent = user.name || "--";
  loadAvatar(chatAvatar, user.avatar, user.name);
  
  const st = userStatusCache?.[uid];
  chatDot.className = "dot " + (st?.state==="online" ? "online":"offline");
  chatStatus.textContent = st?.state==="online" ? "online" : "offline";
  composer.style.display = "flex";
  messagesEl.innerHTML = "";
  
  updateBlockButtons();
  
  // Mobile navigation
  document.querySelector('.sidebar').classList.remove('active');
  document.querySelector('.chat').classList.add('active');
  
  if(msgListenerRef) msgListenerRef.off();
  const cid = chatId(me.uid, uid);
  msgListenerRef = db.ref("chats/"+cid);
  msgListenerRef.off();
  msgListenerRef.limitToLast(200).on("child_added", snap=>{
    const m = snap.val();
    appendMessage(m, snap.key);
    if(m.from!==me.uid){ 
      createNotificationSound(800, 0.2);
      triggerAndroidNotification(); // Trigger Android notification
      // Mark as delivered
      updateMessageDeliveryStatus(snap.key);
    }
  });
  
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

function updateMessageDeliveryStatus(messageId) {
  if (currentChat) {
    db.ref(`messageStatus/${currentChat}/${messageId}`).set('delivered');
  }
}

function appendMessage(m, messageKey){
  const row = document.createElement("div");
  row.className = "row "+(m.from===me.uid?"out":"in");
  row.dataset.messageId = m.id || 'msg_' + Date.now();
  
  const messageAvatar = document.createElement("img");
  messageAvatar.className = "message-avatar";
  messageAvatar.alt = "Avatar";
  
  if(m.from === me.uid) {
    loadAvatar(messageAvatar, meProfile?.avatar, meProfile?.name);
    messageAvatar.onclick = () => openAvatarViewer(meProfile?.avatar, meProfile?.name);
  } else {
    const senderData = usersCache[m.from] || currentChatUser;
    loadAvatar(messageAvatar, senderData?.avatar, senderData?.name);
    messageAvatar.onclick = () => openAvatarViewer(senderData?.avatar, senderData?.name);
  }
  
  const messageWrapper = document.createElement("div");
  messageWrapper.className = "message-wrapper";
  
  // Add delete button for own messages
  if (m.from === me.uid) {
    const messageActions = document.createElement("div");
    messageActions.className = "message-actions";
    
    const deleteBtn = document.createElement("button");
    deleteBtn.className = "delete-btn";
    deleteBtn.innerHTML = "×";
    deleteBtn.title = "Apagar mensagem";
    deleteBtn.onclick = (e) => {
      e.stopPropagation();
      showConfirmDialog("Tem certeza que deseja apagar esta mensagem?", () => {
        deleteMessage(messageKey, m.id);
      });
    };
    
    messageActions.appendChild(deleteBtn);
    messageWrapper.appendChild(messageActions);
  }
  
  const bubble = document.createElement("div");
  bubble.className = "bubble";
  
  if(m.type==="text"){
    // Check if message is only emojis
    const emojiText = m.text.trim();
    const emojiRegex = /^[\p{Emoji}\s]+$/u;
    const isOnlyEmojis = emojiRegex.test(emojiText) && emojiText.length > 0;
    
    if (isOnlyEmojis) {
      const emojiCount = [...emojiText.replace(/\s/g, '')].length;
      if (emojiCount === 1) {
        bubble.classList.add('emoji-large');
      } else if (emojiCount <= 3) {
        bubble.classList.add('emoji-medium');
      } else if (emojiCount <= 6) {
        bubble.classList.add('emoji-small');
      }
    }
    
    // Use processTextMessage for regular text (preserves line breaks and linkifies)
    bubble.innerHTML = processTextMessage(m.text);
  }else if(m.type==="image"){
    const img = document.createElement("img");
    img.className = "msg-img";
    img.src = m.url;
    img.alt = "imagem";
    img.onclick = ()=> openViewer(m.url);
    bubble.appendChild(img);
    if(m.caption){
      const cap = document.createElement("div"); 
      cap.style.marginTop="6px"; 
      cap.innerHTML = processTextMessage(m.caption);
      bubble.appendChild(cap);
    }
  }else if(m.type==="video-link"){
    // Process video link to show player
    bubble.innerHTML = processVideoPlayer(m.url);
  }
  
  const meta = document.createElement("div");
  meta.className = "meta";
  meta.textContent = formatTime(m.time);
  
  // Add message status for sent messages
  if (m.from === me.uid) {
    const statusSpan = document.createElement("span");
    statusSpan.className = "message-status sent";
    statusSpan.textContent = getStatusIcon('sent');
    meta.appendChild(statusSpan);
  }
  
  messageWrapper.appendChild(bubble);
  messageWrapper.appendChild(meta);
  
  row.appendChild(messageAvatar);
  row.appendChild(messageWrapper);
  
  messagesEl.appendChild(row);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

btnSend.onclick = sendText;

// Removed automatic Enter sending - now only button sends messages
// This allows users to create multi-line messages

function sendText(){
  const txt = (textInput.value||"").trim();
  if(!txt || !currentChat) return;
  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  sendMessage({type:"text", text: txt, id: messageId});
  textInput.value = "";
  createNotificationSound(600, 0.15);
}

// Image upload handler
imageInput.onchange = async (e)=>{
  const file = e.target.files?.[0]; 
  if(!file || !currentChat) return;
  
  try {
    showToast('Enviando imagem...', 'info');
    const url = await uploadToImgBB(file);
    if(!url) return;
    const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    sendMessage({type:"image", url, id: messageId});
    imageInput.value = "";
    showToast('Imagem enviada! 📷', 'success');
  } catch(error) {
    console.error("Erro ao enviar imagem:", error);
    showToast("Erro ao enviar imagem", 'error');
  }
};

// Auto resize textarea
textInput.addEventListener('input', () => {
  textInput.style.height = 'auto';
  textInput.style.height = Math.min(textInput.scrollHeight, 120) + 'px';
});

function sendMessage(payload){
  const to = currentChat;
  const cid = chatId(me.uid, to);
  const m = { from: me.uid, to, time: now(), ...payload };
  const updates = {};
  const newKey = db.ref("chats/"+cid).push().key;
  updates["/chats/"+cid+"/"+newKey] = m;

  // Set initial message status
  updates[`/messageStatus/${me.uid}/${payload.id}`] = 'sent';

  let previewText;
  if (payload.type === "text") {
    previewText = payload.text;
  } else if (payload.type === "image") {
    previewText = "🖼️ Imagem";
  } else if (payload.type === "video-link") {
    previewText = "🎥 Link de vídeo";
  }
  
  const mePrev = { other: to, lastText: previewText, lastTime: m.time };
  const toPrev = { other: me.uid, lastText: previewText, lastTime: m.time };
  updates["/userChats/"+me.uid+"/"+to] = mePrev;
  updates["/userChats/"+to+"/"+me.uid] = toPrev;

  db.ref().update(updates);
}

function openViewer(url){
  viewerImg.src = url;
  viewer.style.display = "grid";
}

viewer.onclick = (e)=>{
  if(e.target===viewer || e.target===viewerClose){ 
    viewer.style.display = "none"; 
    viewerImg.src=""; 
  } 
};

viewerClose.onclick = ()=>{ 
  viewer.style.display = "none"; 
  viewerImg.src=""; 
};

[profileModal, blockedModal].forEach(modal => {
  modal.onclick = (e) => {
    if (e.target === modal) {
      modal.style.display = "none";
    }
  };
});

composer.style.display = "none";

// Mobile navigation
document.addEventListener('DOMContentLoaded', () => {
  const sidebar = document.querySelector('.sidebar');
  const chat = document.querySelector('.chat');

  if (!sidebar || !chat) return;

  sidebar.classList.add('active');
  chat.classList.remove('active');
});

// Swipe gesture for mobile
let touchStartX = 0;
let touchEndX = 0;

document.querySelector('.chat').addEventListener('touchstart', (e) => {
  touchStartX = e.changedTouches[0].screenX;
});

document.querySelector('.chat').addEventListener('touchend', (e) => {
  touchEndX = e.changedTouches[0].screenX;
  handleSwipe();
});

function handleSwipe() {
  const swipeDistance = touchEndX - touchStartX;
  if (swipeDistance > 80) {
    goToHome();
  }
}
</script>
</body>
</html>